{"version":3,"file":"lazy-chunk-request-sign-transaction-bitcoin.es.js","sources":["source-mapped://source-mapped/src/high-level-api/requests/bitcoin/request-sign-transaction-bitcoin.ts"],"sourcesContent":["import RequestBitcoin from './request-bitcoin';\nimport { AddressTypeBitcoin, Coin, Network, RequestTypeBitcoin } from '../../constants';\nimport { parseBip32Path } from '../../bip32-utils';\nimport ErrorState, { ErrorType } from '../../error-state';\n\ntype Transport = import('@ledgerhq/hw-transport').default;\ntype BitcoinJsTransaction = import('bitcoinjs-lib').Transaction;\ntype BitcoinLib = typeof import('./bitcoin-lib');\ntype CreateTransactionArg = Parameters<import('@ledgerhq/hw-app-btc').default['createPaymentTransactionNew']>[0];\n// serializeTransactionOutputs is typed unnecessarily strict as it only uses the outputs of a transaction\ntype FixedSerializeTransactionOutputs =\n    (tx: Pick<Parameters<import('@ledgerhq/hw-app-btc').default['serializeTransactionOutputs']>[0], 'outputs'>)\n    => ReturnType<import('@ledgerhq/hw-app-btc').default['serializeTransactionOutputs']>;\n\nexport interface TransactionInfoBitcoin {\n    // The inputs to consume for this transaction (prev outs). All inputs have to be of the same type (native segwit,\n    // p2sh segwit or legacy), determined from their key paths.\n    inputs: Array<{\n        // full input transaction of which to take the output as input, either as serialized hex or in bitcoinjs-lib\n        // transaction format\n        transaction: string | BitcoinJsTransaction,\n        // index of the transaction's output which is now to be used as input\n        index: number,\n        // bip32 path of the key which needs to sign for redeeming the input (e.g. the previous \"recipient\")\n        keyPath: string,\n        // hex, optional custom script to be signed for consuming an input. This can be a witness script for segwit\n        // transactions (native segwit or p2sh segwit), or a redeem script for other p2sh transactions. Use this for\n        // example to redeem from contracts or multisigs. For regular transaction you'll typically not need to set this\n        // yourself as sensible defaults are used: for legacy transactions the prevOut output script is used; for segwit\n        // transactions an appropriate default script from the public key at keyPath.\n        customScript?: string,\n        // optional sequence number to use for this input when using replace by fee (RBF)\n        sequence?: number,\n    }>;\n    // the serialized outputs as hex or the separate outputs specified by amount and outputScript or address. Note that\n    // if you are sending part of the funds back to an address as change, that output also needs to be included here.\n    // Arbitrary output types can be used, also differing from input type and among themselves. Input coins which are\n    // not sent to an output are considered fee.\n    outputs: string | Array<{\n        // amount in Satoshi; non-fractional positive number\n        amount: number,\n    } & ({\n        outputScript: string, // hex encoded serialized output script\n    } | {\n        // bitcoin recipient address. This address gets transformed into an output script. If you already have the\n        // output script available or a library loaded for calculating it, it's preferable to provide the outputScript\n        // instead of the address to avoid the need to load an additional library for conversion here.\n        address: string,\n    })>;\n    // optional bip32 path of potential change output. If your outputs include a change output back to this ledger, you\n    // should specify that key's bip32 path here such that the Ledger can verify the change output's correctness and\n    // doesn't need the user to confirm the change output. The change type can also be different than the input type.\n    changePath?: string;\n    // optional lockTime; 0 by default\n    lockTime?: number;\n    // optional hash type specifying how to sign the transaction, SIGHASH_ALL (0x01) by default. Before changing this,\n    // make sure in https://github.com/LedgerHQ/app-bitcoin/blob/master/src/btchip_apdu_hash_sign.c that your desired\n    // sigHashType is supported.\n    sigHashType?: number;\n    // Enforce input amount verification also for segwit inputs. Note that on Bitcoin app >= 1.4.0 a warning is\n    // displayed on the Ledger screen for unverified native segwit inputs and that for app versions < 1.4.0 setting\n    // useTrustedInputForSegwit is not supported. By default it's automatically set according to connected app version.\n    useTrustedInputForSegwit?: false;\n}\n\nexport default class RequestSignTransactionBitcoin extends RequestBitcoin<string> {\n    public readonly type: RequestTypeBitcoin.SIGN_TRANSACTION = RequestTypeBitcoin.SIGN_TRANSACTION;\n    public readonly transaction: TransactionInfoBitcoin;\n    public readonly network: Network;\n    private _inputType: AddressTypeBitcoin;\n\n    constructor(transaction: TransactionInfoBitcoin, expectedWalletId?: string) {\n        super(expectedWalletId);\n\n        this.transaction = transaction;\n\n        try {\n            const { inputs, outputs, changePath } = transaction;\n\n            if (!inputs.length) {\n                throw new Error('No inputs specified');\n            }\n            if (!outputs.length) {\n                throw new Error('No outputs specified');\n            }\n\n            // verify key paths\n            const keyPaths = [\n                ...inputs.map((input) => input.keyPath),\n                ...(changePath ? [changePath] : []),\n            ];\n            let network: Network | null = null;\n            let inputType: AddressTypeBitcoin | null = null;\n            for (const keyPath of keyPaths) {\n                const parsedKeyPath = parseBip32Path(keyPath);\n                if (parsedKeyPath.coin !== Coin.BITCOIN) {\n                    throw new Error(`${keyPath} not a Bitcoin bip32 path following bip44`);\n                }\n\n                // Note that we don't have to verify the network of outputs. They will be displayed on the ledger screen\n                // depending on whether Bitcoin mainnet or testnet app is used. User will spot differences.\n                if (network && parsedKeyPath.network !== network) {\n                    throw new Error('Not all key paths specify keys on the same network');\n                }\n                network = parsedKeyPath.network;\n\n                // Note that we don't have to verify the address type of outputs and change; these can be arbitrary.\n                // Inputs must all be of the same type because Ledger's signing of input depends on parameter segwit and\n                // whether bech32 is set as an additional, i.e. all inputs are treated the same and signed according to\n                // these parameters. The transaction could be split and each input be signed separately but that would\n                // be a lot of work.\n                if (keyPath === changePath) continue; // could still also be an input, but we ignore that corner case\n                if (inputType && parsedKeyPath.addressType !== inputType) {\n                    throw new Error('Must not use mixed input types');\n                }\n                inputType = parsedKeyPath.addressType;\n            }\n            this.network = network!;\n            this._inputType = inputType!;\n        } catch (e) {\n            throw new ErrorState(\n                ErrorType.REQUEST_ASSERTION_FAILED,\n                `Invalid request: ${e.message || e}`,\n                this,\n            );\n        }\n\n        // Preload Bitcoin lib if needed. Ledger Bitcoin api is already preloaded by parent class. Ignore errors.\n        this._loadBitcoinLibIfNeeded().catch(() => {});\n    }\n\n    public async call(transport: Transport): Promise<string> {\n        // Resources:\n        // - to learn more about scripts and how input and output script relate to each other:\n        //   https://en.bitcoin.it/wiki/Script\n        // - to learn more about transactions in general, what they include and their encoding:\n        //   https://en.bitcoin.it/wiki/Transaction\n        // - code for decoding of transactions for a deeper understanding:\n        //   https://github.com/bitcoinjs/bitcoinjs-lib/blob/master/ts_src/transaction.ts (BitcoinJS)\n        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/splitTransaction.js (parsing into\n        //   Ledger's representation. Code is a bit messy.)\n        // - Ledger's notion of trusted inputs to connect inputs to their amount in a trusted fashion by rehashing the\n        //   input transaction:\n        //   https://bitcoinmagazine.com/articles/how-segregated-witness-is-about-to-fix-hardware-wallets-1478110057\n        //   https://medium.com/segwit-co/segregated-witness-and-hardware-wallets-cc88ba532fb3\n        // - @ledgerhq/hw-app-btc documentation:\n        //   https://github.com/LedgerHQ/ledgerjs/tree/master/packages/hw-app-btc\n        // - @ledgerhq/hw-app-btc transaction building and signing logic:\n        //   https://github.com/LedgerHQ/ledgerjs/blob/master/packages/hw-app-btc/src/createTransaction.js\n        // - Ledger Bitcoin App's api description:\n        //   https://github.com/LedgerHQ/app-bitcoin/blob/master/doc/btc.asc\n        // - @ledgerhq/hw-app-btc's tests to see an example of correctly sent data:\n        //   https://github.com/LedgerHQ/ledgerjs/tree/master/packages/hw-app-btc/tests\n        // - For decoding transactions:\n        //   https://live.blockcypher.com/btc/decodetx/\n        // - The demo page and code of this lib for demo usage\n\n        const [api, bitcoinLib] = await Promise.all([\n            // these throw LOADING_DEPENDENCIES_FAILED on failure\n            this._getLowLevelApi(transport),\n            this._loadBitcoinLibIfNeeded(),\n        ]);\n        let parsedTransaction: CreateTransactionArg;\n\n        try {\n            // parse into Ledger's CreateTransactionArg format\n            const {\n                inputs,\n                outputs,\n                changePath,\n                lockTime,\n                sigHashType,\n                useTrustedInputForSegwit,\n            } = this.transaction;\n\n            parsedTransaction = {\n                inputs: inputs.map(({ transaction, index, customScript, sequence }) => [\n                    api.splitTransaction(\n                        typeof transaction === 'string' ? transaction : transaction.toHex(),\n                        // Set segwit support always to true because then transactions with and without witnesses are\n                        // correctly parsed (compare bitcoinjs/transaction). Also we can't set it depending on whether\n                        // our own input (transaction's output) is not segwit because it's input might be. Specifically\n                        // fixes parsing legacy inputs which came from segwit inputs.\n                        true,\n                    ),\n                    index,\n                    customScript || null,\n                    sequence || null,\n                ]),\n                associatedKeysets: inputs.map(({ keyPath }) => keyPath),\n                outputScriptHex: typeof outputs === 'string'\n                    ? outputs\n                    : (api.serializeTransactionOutputs as FixedSerializeTransactionOutputs)({\n                        outputs: outputs.map((output) => {\n                            // inspired by how outputs are encoded in __toBuffer in bitcoinjs-lib/transaction.ts\n                            const { amount } = output;\n                            if (Math.floor(amount) !== amount || amount < 0 || amount > 21e9) {\n                                throw new Error(`Invalid Satoshi amount: ${amount}`);\n                            }\n                            const amountBuffer = Buffer.alloc(8);\n                            amountBuffer.writeInt32LE(amount & -1, 0); // eslint-disable-line no-bitwise\n                            amountBuffer.writeUInt32LE(Math.floor(amount / 0x100000000), 4);\n\n                            let outputScript: Buffer;\n                            if ('outputScript' in output) {\n                                outputScript = Buffer.from(output.outputScript, 'hex');\n                            } else {\n                                outputScript = bitcoinLib!.address.toOutputScript(\n                                    output.address,\n                                    this.network === Network.MAINNET\n                                        ? bitcoinLib!.networks.bitcoin\n                                        : bitcoinLib!.networks.testnet,\n                                );\n                            }\n                            return { amount: amountBuffer, script: outputScript };\n                        }),\n                    }).toString('hex'),\n                segwit: this._inputType !== AddressTypeBitcoin.LEGACY,\n                additionals: this._inputType === AddressTypeBitcoin.NATIVE_SEGWIT ? ['bech32'] : [],\n            };\n\n            // Set optional properties. Note that we did not use ...this.transaction via object spreading above to avoid\n            // setting properties to undefined for which the default values would not be applied anymore in the api call\n            if (changePath !== undefined && changePath !== null) {\n                parsedTransaction.changePath = changePath;\n            }\n            if (lockTime !== undefined && lockTime !== null) {\n                parsedTransaction.lockTime = lockTime;\n            }\n            if (sigHashType !== undefined && sigHashType !== null) {\n                parsedTransaction.sigHashType = sigHashType;\n            }\n            if (useTrustedInputForSegwit !== undefined && useTrustedInputForSegwit !== null) {\n                parsedTransaction.useTrustedInputForSegwit = useTrustedInputForSegwit;\n            }\n        } catch (e) {\n            throw new ErrorState(ErrorType.REQUEST_ASSERTION_FAILED, e, this);\n        }\n\n        // Note: We make api calls outside of the try...catch block to let the exceptions fall through such that\n        // _callLedger can decide how to behave depending on the api error.\n        return api.createPaymentTransactionNew(parsedTransaction);\n    }\n\n    private async _loadBitcoinLibIfNeeded(): Promise<null | BitcoinLib> {\n        // If we need bitcoinjs for address to output script conversion, load it.\n        if (Array.isArray(this.transaction.outputs)\n            && this.transaction.outputs.some((output) => 'address' in output && !!output.address)) {\n            return this._loadBitcoinLib();\n        }\n        return null;\n    }\n}\n"],"names":[],"mappings":"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"}