{"version":3,"file":"ledger-api.es.js","sources":["source-mapped://source-mapped/src/lib/load-nimiq.ts","source-mapped://source-mapped/src/low-level-api/low-level-api-utils.ts","source-mapped://source-mapped/src/low-level-api/low-level-api.ts","source-mapped://source-mapped/src/lib/observable.ts","source-mapped://source-mapped/src/high-level-api/transport-utils.ts","source-mapped://source-mapped/src/high-level-api/ledger-api-request.ts","source-mapped://source-mapped/src/high-level-api/ledger-api.ts"],"sourcesContent":["type Nimiq = typeof import('@nimiq/core-web');\n\n// Use jsdelivr instead of nimiq cdn to avoid getting blocked by ad blockers.\nconst coreBasePath = 'https://cdn.jsdelivr.net/npm/@nimiq/core-web/';\n\nlet nimiqCorePromise: Promise<Nimiq> | null = null;\n\n/**\n * Lazy-load the Nimiq core api from the cdn server if it's not loaded yet.\n */\nexport async function loadNimiqCore(coreVariant: 'web' | 'web-offline' = 'web-offline'): Promise<Nimiq> {\n    // @ts-ignore Return global Nimiq if already loaded.\n    if (window.Nimiq) return window.Nimiq;\n\n    nimiqCorePromise = nimiqCorePromise || new Promise((resolve, reject) => {\n        const $head = document.getElementsByTagName('head')[0];\n        const $script = document.createElement('script');\n        $script.type = 'text/javascript';\n        $script.onload = () => {\n            $script.parentNode!.removeChild($script);\n            resolve();\n        };\n        $script.onerror = (e) => {\n            $script.parentNode!.removeChild($script);\n            reject(e);\n        };\n        $script.src = `${coreBasePath}${coreVariant}.js`;\n        $head.appendChild($script);\n    }).then(\n        () => {\n            // @ts-ignore Nimiq is global but to discourage usage as global var we did not declare a global type.\n            const { Nimiq } = window;\n            return Nimiq;\n        },\n        (e) => {\n            nimiqCorePromise = null;\n            return Promise.reject(e);\n        },\n    );\n    return nimiqCorePromise;\n}\n\n/**\n * Load the WebAssembly and module for cryptographic functions. You will have to do this before calculating hashes,\n * deriving keys or addresses, signing transactions or messages, etc.\n */\nexport async function loadNimiqCryptography(): Promise<void> {\n    // Note that there is no need to cache a promise like in loadNimiqCore for this call, as loadNimiqCore and doImport\n    // already do that themselves.\n    const Nimiq = await loadNimiqCore();\n    await Nimiq.WasmHelper.doImport();\n}\n","import { loadNimiqCore, loadNimiqCryptography } from '../lib/load-nimiq';\n\nexport function parsePath(path: string): Buffer {\n    if (!path.startsWith('44\\'/242\\'')) {\n        throw new Error(\n            `Not a Nimiq BIP32 path. Path: ${path}. The Nimiq app is authorized only for paths starting with 44'/242'. `\n            + ' Example: 44\\'/242\\'/0\\'/0\\'',\n        );\n    }\n\n    const pathParts: number[] = path.split('/').map((part) => {\n        let number = parseInt(part, 10);\n        if (Number.isNaN(number)) {\n            throw new Error(`Invalid path: ${path}`);\n        }\n        if (part.endsWith('\\'')) {\n            number += 0x80000000;\n        } else {\n            throw new Error(\n                'Detected a non-hardened path element in requested BIP32 path.'\n                + ' Non-hardended paths are not supported at this time. Please use an all-hardened path.'\n                + ' Example: 44\\'/242\\'/0\\'/0\\'',\n            );\n        }\n        return number;\n    });\n\n    const pathBuffer = Buffer.alloc(1 + pathParts.length * 4);\n    pathBuffer[0] = pathParts.length;\n    pathParts.forEach((element, index) => {\n        pathBuffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return pathBuffer;\n}\n\nexport async function publicKeyToAddress(publicKey: Buffer): Promise<string> {\n    const [Nimiq] = await Promise.all([\n        loadNimiqCore(),\n        loadNimiqCryptography(), // needed for hashing public key to an address\n    ]);\n    return Nimiq.PublicKey.unserialize(new Nimiq.SerialBuffer(publicKey)).toAddress().toUserFriendlyAddress();\n}\n\nexport async function verifySignature(\n    data: Buffer,\n    signature: Buffer,\n    publicKey: Buffer,\n): Promise<boolean> {\n    const [Nimiq] = await Promise.all([loadNimiqCore(), loadNimiqCryptography()]);\n    const nimiqSignature = Nimiq.Signature.unserialize(new Nimiq.SerialBuffer(signature));\n    const nimiqPublicKey = Nimiq.PublicKey.unserialize(new Nimiq.SerialBuffer(publicKey));\n    return nimiqSignature.verify(nimiqPublicKey, data);\n}\n","import {\n    parsePath,\n    publicKeyToAddress,\n    verifySignature,\n} from './low-level-api-utils';\nimport { loadNimiqCore, loadNimiqCryptography } from '../lib/load-nimiq';\n\ntype Transport = import('@ledgerhq/hw-transport').default;\n\nconst CLA = 0xe0;\nconst INS_GET_PK = 0x02;\nconst INS_SIGN_TX = 0x04;\nconst INS_GET_CONF = 0x06;\nconst INS_KEEP_ALIVE = 0x08;\n\nconst APDU_MAX_SIZE = 150;\nconst P1_FIRST_APDU = 0x00;\nconst P1_MORE_APDU = 0x80;\nconst P1_NO_VALIDATE = 0x00;\nconst P1_VALIDATE = 0x01;\nconst P2_LAST_APDU = 0x00;\nconst P2_MORE_APDU = 0x80;\nconst P2_NO_CONFIRM = 0x00;\nconst P2_CONFIRM = 0x01;\n\nconst SW_OK = 0x9000;\nconst SW_CANCEL = 0x6985;\nconst SW_KEEP_ALIVE = 0x6e02;\n\n// The @ledgerhq libraries use Node Buffers which need to be polyfilled in the browser. To avoid the need to bundle such\n// polyfills that an app likely already has bundled in the @ledgerhq libraries, this library expects a global polyfill\n// declared on window.\ndeclare global {\n    interface Window {\n        Buffer?: typeof Buffer;\n    }\n}\n\n/**\n * Nimiq API\n *\n * Low level api for communication with the Ledger wallet Nimiq app. This lib is compatible with all @ledgerhq/transport\n * libraries but does on the other hand not include optimizations for specific transport types and returns raw bytes.\n *\n * This library is in nature similar to other hw-app packages in @ledgerhq/ledgerjs and partially based on their code,\n * licenced under the Apache 2.0 licence.\n *\n * @example\n * const nim = new LowLevelApi(transport)\n */\nexport default class LowLevelApi {\n    private _transport: Transport;\n\n    constructor(transport: Transport) {\n        this._transport = transport;\n        transport.decorateAppAPIMethods(\n            this,\n            ['getAppConfiguration', 'getPublicKey', 'signTransaction'],\n            'w0w',\n        );\n    }\n\n    /**\n     * Close the transport instance. Note that this does not emit a disconnect. Disconnects are only emitted when the\n     * device actually disconnects (or switches it's descriptor which happens when switching to the dashboard or apps).\n     */\n    public close() {\n        try {\n            this._transport.close();\n        } catch (e) {\n            // Ignore. Transport might already be closed.\n        }\n    }\n\n    /**\n     * Get the version of the connected Ledger Nimiq App. Note that some other apps like the Ethereum app also respond\n     * to this call.\n     */\n    public async getAppConfiguration(): Promise<{ version: string }> {\n        // Note that no heartbeat is required here as INS_GET_CONF is not interactive but thus answers directly\n        const [, major, minor, patch] = await this._transport.send(CLA, INS_GET_CONF, 0x00, 0x00);\n        const version = `${major}.${minor}.${patch}`;\n        return { version };\n    }\n\n    /**\n     * Get Nimiq address for a given BIP 32 path.\n     * @param path - A path in BIP 32 format.\n     * @param boolValidate - Optionally enable key pair validation.\n     * @param boolDisplay - Optionally display the address on the ledger.\n     * @returns An object with the address.\n     * @example\n     * nim.getAddress(\"44'/242'/0'/0'\").then(o => o.address)\n     */\n    public async getAddress(\n        path: string,\n        boolValidate: boolean = true,\n        boolDisplay: boolean = false,\n    ): Promise<{ address: string }> {\n        // start loading Nimiq core later needed for transforming public key to address and optional validation\n        loadNimiqCore();\n        loadNimiqCryptography();\n\n        const { publicKey } = await this.getPublicKey(path, boolValidate, boolDisplay);\n        const address = await publicKeyToAddress(Buffer.from(publicKey));\n        return { address };\n    }\n\n    /**\n     * Get Nimiq public key for a given BIP 32 path.\n     * @param path - A path in BIP 32 format.\n     * @param boolValidate - Optionally enable key pair validation.\n     * @param boolDisplay - Optionally display the corresponding address on the ledger.\n     * @returns An object with the publicKey.\n     * @example\n     * nim.getPublicKey(\"44'/242'/0'/0'\").then(o => o.publicKey)\n     */\n    public async getPublicKey(\n        path: string,\n        boolValidate: boolean = true,\n        boolDisplay: boolean = false,\n    ): Promise<{ publicKey: Uint8Array }> {\n        if (boolValidate) {\n            // start loading Nimiq core later needed for validation\n            loadNimiqCore();\n            loadNimiqCryptography();\n        }\n\n        const pathBuffer = parsePath(path);\n        const verifyMsg = Buffer.from('p=np?', 'ascii');\n        const data = Buffer.concat([pathBuffer, verifyMsg]);\n\n        let response: Buffer;\n        response = await this._transport.send(\n            CLA,\n            INS_GET_PK,\n            boolValidate ? P1_VALIDATE : P1_NO_VALIDATE,\n            boolDisplay ? P2_CONFIRM : P2_NO_CONFIRM,\n            data,\n            [SW_OK, SW_KEEP_ALIVE],\n        );\n        // handle heartbeat\n        while (response.slice(response.length - 2).readUInt16BE(0) === SW_KEEP_ALIVE) {\n            // eslint-disable-next-line no-await-in-loop\n            response = await this._transport.send(CLA, INS_KEEP_ALIVE, 0, 0, undefined, [SW_OK, SW_KEEP_ALIVE]);\n        }\n\n        let offset = 0;\n        const publicKey = response.slice(offset, offset + 32);\n        offset += 32;\n        if (boolValidate) {\n            const signature = response.slice(offset, offset + 64);\n            if (!await verifySignature(verifyMsg, signature, publicKey)) {\n                throw new Error(\n                    'Bad signature. Keypair is invalid. Please report this.',\n                );\n            }\n        }\n        return { publicKey };\n    }\n\n    /**\n     * Sign a Nimiq transaction.\n     * @param path - A path in BIP 32 format.\n     * @param txContent - Transaction content in serialized form.\n     * @returns An object with the signature.\n     * @example\n     * nim.signTransaction(\"44'/242'/0'/0'\", signatureBase).then(o => o.signature)\n     */\n    public async signTransaction(\n        path: string,\n        txContent: Uint8Array,\n    ): Promise<{ signature: Uint8Array }> {\n        const pathBuffer = parsePath(path);\n        const transaction = Buffer.from(txContent);\n        const apdus = [];\n        let chunkSize = APDU_MAX_SIZE - pathBuffer.length;\n        if (transaction.length <= chunkSize) {\n            // it fits in a single apdu\n            apdus.push(Buffer.concat([pathBuffer, transaction]));\n        } else {\n            // we need to send multiple apdus to transmit the entire transaction\n            let chunk = Buffer.alloc(chunkSize);\n            let offset = 0;\n            transaction.copy(chunk, 0, offset, chunkSize);\n            apdus.push(Buffer.concat([pathBuffer, chunk]));\n            offset += chunkSize;\n            while (offset < transaction.length) {\n                const remaining = transaction.length - offset;\n                chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;\n                chunk = Buffer.alloc(chunkSize);\n                transaction.copy(chunk, 0, offset, offset + chunkSize);\n                offset += chunkSize;\n                apdus.push(chunk);\n            }\n        }\n\n        let isHeartbeat = false;\n        let chunkIndex = 0;\n        let status: number;\n        let response: Buffer;\n        do {\n            const data = apdus[chunkIndex];\n            // eslint-disable-next-line no-await-in-loop\n            response = await this._transport.send(\n                CLA,\n                isHeartbeat ? INS_KEEP_ALIVE : INS_SIGN_TX,\n                chunkIndex === 0 ? P1_FIRST_APDU : P1_MORE_APDU, // note that for heartbeat p1, p2 and data are ignored\n                chunkIndex === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU,\n                data,\n                [SW_OK, SW_CANCEL, SW_KEEP_ALIVE],\n            );\n            status = response.slice(response.length - 2).readUInt16BE(0);\n            isHeartbeat = status === SW_KEEP_ALIVE;\n            if (!isHeartbeat) {\n                // we can continue sending data or end the loop when all data was sent\n                ++chunkIndex;\n            }\n        } while (isHeartbeat || chunkIndex < apdus.length);\n\n        if (status !== SW_OK) throw new Error('Transaction approval request was rejected');\n        const signature = Buffer.from(response.slice(0, response.length - 2));\n        return {\n            signature: Uint8Array.from(signature),\n        };\n    }\n}\n","export type EventListener = (...args: any[]) => void;\n\nexport default class Observable {\n    private _listeners: Map<string, EventListener[]> = new Map();\n\n    public on(eventType: string, listener: EventListener): void {\n        if (!this._listeners.has(eventType)) {\n            this._listeners.set(eventType, [listener]);\n        } else {\n            this._listeners.get(eventType)!.push(listener);\n        }\n    }\n\n    public off(eventType: string, listener: EventListener): void {\n        const listenersForEvent = this._listeners.get(eventType);\n        if (!listenersForEvent) return;\n        const index = listenersForEvent.indexOf(listener);\n        if (index === -1) return;\n        listenersForEvent.splice(index, 1);\n    }\n\n    public once(eventType: string, listener: EventListener): void {\n        const onceListener: EventListener = ((...args: any[]) => {\n            this.off(eventType, onceListener);\n            listener(...args);\n        });\n        this.on(eventType, onceListener);\n    }\n\n    public fire(eventName: string, ...args: any[]): void {\n        // Let current micro task finish before invoking listeners\n        setTimeout(() => {\n            const listenersForEvent = this._listeners.get(eventName);\n            if (!listenersForEvent) return;\n            for (const listener of listenersForEvent) {\n                listener(...args);\n            }\n        }, 0);\n    }\n}\n","type TransportConstructor = typeof import('@ledgerhq/hw-transport').default;\ntype TransportWebUsbConstructor = typeof import('@ledgerhq/hw-transport-webusb').default;\n\nexport enum TransportType {\n    WEB_HID = 'web-hid',\n    WEB_USB = 'web-usb',\n    WEB_BLE = 'web-ble',\n    WEB_AUTHN = 'web-authn',\n    U2F = 'u2f',\n}\n\nexport function isSupported(transportType?: TransportType): boolean {\n    if (window.location.protocol !== 'https:') return false;\n    if (!transportType) return !!autoDetectTransportTypeToUse();\n    // inspired by @ledgerhq/hw-transport libs\n    switch (transportType) {\n        case TransportType.WEB_HID:\n            return 'hid' in window.navigator;\n        case TransportType.WEB_USB:\n            // @ts-ignore\n            return 'usb' in window.navigator && typeof window.navigator.usb.getDevices === 'function';\n        case TransportType.WEB_BLE:\n            return 'bluetooth' in window.navigator;\n        case TransportType.WEB_AUTHN:\n            return !!navigator.credentials;\n        case TransportType.U2F:\n            // Note that Chrome, Opera and Edge use an internal, hidden cryptotoken extension to handle u2f\n            // (https://github.com/google/u2f-ref-code/blob/master/u2f-gae-demo/war/js/u2f-api.js) which does not\n            // expose the u2f api on window. Support via that extension is not detected by this check. However, as\n            // these browsers support WebUSB, this is acceptable and we don't use a more elaborate check like the one\n            // in the 'u2f-api' package to avoid bundling it and also because it's async, complicating the code.\n            // @ts-ignore\n            return 'u2f' in window && typeof window.u2f.sign === 'function';\n        default:\n            return false;\n    }\n}\n\nexport function autoDetectTransportTypeToUse(): TransportType | null {\n    // Determine the best available transport type. Exclude WebBle as it's only suitable for Nano X.\n    let transportTypesByPreference;\n    // HID has better compatibility on Windows due to driver issues for WebUSB for the Nano X. On other\n    // platforms however, WebUSB is preferable for multiple reasons (see transport-comparison.md).\n    // TODO this situation needs to be re-evaluated once WebHID is stable\n    const isWindows = /Win/.test(window.navigator.platform); // see https://stackoverflow.com/a/38241481\n    if (isWindows) {\n        transportTypesByPreference = [TransportType.WEB_HID, TransportType.WEB_USB];\n    } else {\n        transportTypesByPreference = [TransportType.WEB_USB, TransportType.WEB_HID];\n    }\n    // WebAuthn as preferred fallback, as compared to U2F better browser support and less quirky / not deprecated and\n    // works better with Nano X. But causes a popup in Chrome which U2F does not. In Firefox has same popup as U2F and\n    // in Windows also triggers Window's native security popup (see transport-comparison.md).\n    transportTypesByPreference.push(TransportType.WEB_AUTHN);\n    // U2F as legacy fallback. The others are preferred as U2F can time out and causes native Windows security popups\n    // in Windows and additionally Firefox internal popups in Firefox on all platforms (see transport-comparison.md).\n    transportTypesByPreference.push(TransportType.U2F);\n    return transportTypesByPreference.find(isSupported) || null;\n}\n\n/**\n * Lazy load the library for a transport type.\n * @param transportType\n */\nexport async function loadTransportLibrary(transportType: TransportType)\n    : Promise<TransportWebUsbConstructor|TransportConstructor> {\n    switch (transportType) {\n        case TransportType.WEB_HID:\n            return (await import('@ledgerhq/hw-transport-webhid')).default;\n        case TransportType.WEB_USB:\n            return (await import('@ledgerhq/hw-transport-webusb')).default;\n        case TransportType.WEB_BLE:\n            return (await import('@ledgerhq/hw-transport-web-ble')).default;\n        case TransportType.WEB_AUTHN:\n            return (await import('@ledgerhq/hw-transport-webauthn')).default;\n        case TransportType.U2F:\n            return (await import('@ledgerhq/hw-transport-u2f')).default;\n        default:\n            throw new Error(`Unknown transport type ${transportType}`);\n    }\n}\n","import Observable, { EventListener } from '../lib/observable';\n\ntype LowLevelApi = import('../low-level-api/low-level-api').default;\ntype TransactionInfo = import('./ledger-api').TransactionInfo;\n\nexport enum RequestType {\n    GET_WALLET_ID = 'get-wallet-id',\n    DERIVE_ADDRESSES = 'derive-addresses',\n    GET_PUBLIC_KEY = 'get-public-key',\n    GET_ADDRESS = 'get-address',\n    CONFIRM_ADDRESS = 'confirm-address',\n    SIGN_TRANSACTION = 'sign-transaction',\n}\n\nexport interface RequestParams {\n    walletId?: string; // optional for all calls\n    keyPath?: string; // for everything besides DERIVE_ADDRESSES\n    pathsToDerive?: Iterable<string>; // for DERIVE_ADDRESSES\n    addressToConfirm?: string; // for CONFIRM_TRANSACTION\n    transaction?: TransactionInfo; // for SIGN_TRANSACTION\n}\n\nexport default class LedgerApiRequest<T> extends Observable {\n    public static readonly EVENT_CANCEL = 'cancel';\n    public readonly type: RequestType;\n    public readonly params: RequestParams;\n    private readonly _call: (api: LowLevelApi, params: RequestParams) => Promise<T>;\n    private _cancelled: boolean = false;\n\n    constructor(\n        type: RequestType,\n        call: (api: LowLevelApi, params: RequestParams) => Promise<T>,\n        params: RequestParams,\n    ) {\n        super();\n        this.type = type;\n        this._call = call;\n        this.params = params;\n    }\n\n    public get cancelled(): boolean {\n        return this._cancelled;\n    }\n\n    public async call(api: LowLevelApi): Promise<T> {\n        return this._call.call(this, api, this.params);\n    }\n\n    public cancel(): void {\n        if (this._cancelled) return;\n        this._cancelled = true;\n        this.fire(LedgerApiRequest.EVENT_CANCEL);\n    }\n\n    public on(type: string, callback: EventListener): void {\n        if (type === LedgerApiRequest.EVENT_CANCEL && this._cancelled) {\n            // trigger callback directly\n            callback();\n        }\n        return super.on(type, callback);\n    }\n}\n","import LowLevelApi from '../low-level-api/low-level-api';\nimport Observable, { EventListener } from '../lib/observable';\nimport { loadNimiqCore, loadNimiqCryptography } from '../lib/load-nimiq';\nimport { autoDetectTransportTypeToUse, loadTransportLibrary, isSupported, TransportType } from './transport-utils';\nimport LedgerApiRequest, { RequestParams, RequestType } from './ledger-api-request';\n\ntype TransportConstructor = typeof import('@ledgerhq/hw-transport').default;\ntype TransportWebUsbConstructor = typeof import('@ledgerhq/hw-transport-webusb').default;\n\ntype Nimiq = typeof import('@nimiq/core-web');\ntype Address = import('@nimiq/core-web').Address;\ntype AccountType = import('@nimiq/core-web').Account.Type;\ntype Transaction = import('@nimiq/core-web').Transaction;\ntype PublicKey = import('@nimiq/core-web').PublicKey;\n\nexport { RequestType, RequestParams };\nexport { isSupported, TransportType };\n\n// events appear at a single point of time while states reflect the current state of the api for a timespan ranging\n// into the future. E.g. if a request was cancelled, a REQUEST_CANCELLED event gets thrown and the state changes to\n// IDLE. Errors trigger an error state (e.g. when app outdated) and thus are a state, not an event.\nexport enum EventType {\n    STATE_CHANGE = 'state-change',\n    REQUEST_SUCCESSFUL = 'request-successful',\n    REQUEST_CANCELLED = 'request-cancelled',\n    CONNECTED = 'connected',\n}\n\nexport enum StateType {\n    IDLE = 'idle',\n    LOADING = 'loading',\n    CONNECTING = 'connecting',\n    REQUEST_PROCESSING = 'request-processing',\n    REQUEST_CANCELLING = 'request-cancelling',\n    ERROR = 'error',\n}\n\nexport enum ErrorType {\n    LEDGER_BUSY = 'ledger-busy',\n    LOADING_DEPENDENCIES_FAILED = 'loading-dependencies-failed',\n    USER_INTERACTION_REQUIRED = 'user-interaction-required',\n    CONNECTION_ABORTED = 'connection-aborted',\n    NO_BROWSER_SUPPORT = 'no-browser-support',\n    APP_OUTDATED = 'app-outdated',\n    WRONG_LEDGER = 'wrong-ledger',\n    REQUEST_ASSERTION_FAILED = 'request-specific-error',\n}\n\nexport interface State {\n    type: StateType;\n    error?: {\n        type: ErrorType,\n        message: string,\n    };\n    request?: LedgerApiRequest<any>;\n}\n\nexport interface TransactionInfo {\n    sender: Address;\n    senderType?: AccountType;\n    recipient: Address;\n    recipientType?: AccountType;\n    value: number; // In Luna\n    fee?: number;\n    validityStartHeight: number;\n    network?: 'main' | 'test' | 'dev';\n    flags?: number;\n    extraData?: Uint8Array;\n}\n\nexport default class LedgerApi {\n    // public fields and methods\n    public static readonly BIP32_BASE_PATH = '44\\'/242\\'/0\\'/';\n    public static readonly BIP32_PATH_REGEX = new RegExp(`^${LedgerApi.BIP32_BASE_PATH}(\\\\d+)'$`);\n    public static readonly MIN_REQUIRED_APP_VERSION = [1, 4, 2];\n    public static readonly WAIT_TIME_AFTER_TIMEOUT = 1500;\n    public static readonly WAIT_TIME_AFTER_ERROR = 500;\n\n    public static get currentState(): State {\n        return LedgerApi._currentState;\n    }\n\n    public static get currentRequest(): LedgerApiRequest<any> | null {\n        return LedgerApi._currentRequest;\n    }\n\n    public static get isBusy(): boolean {\n        return !!LedgerApi._currentRequest;\n    }\n\n    public static get transportType(): TransportType | null {\n        return LedgerApi._transportType;\n    }\n\n    /**\n     * Check for general support or support of a specific transport type. Note that isSupported is additionally exported\n     * as separate export that doesn't require bundling the whole api.\n     * @param [transportType] - Transport type for which to test for support. If omitted test for support of any type.\n     */\n    public static isSupported(transportType?: TransportType): boolean {\n        return isSupported(transportType);\n    }\n\n    /**\n     * Set a specific transport type. Note that an already connected ongoing request will still use the previous\n     * transport type.\n     * @param transportType - Transport type to use for connections to Ledger devices.\n     */\n    public static setTransportType(transportType: TransportType) {\n        if (!isSupported(transportType)) throw new Error('Unsupported transport type.');\n        if (transportType === LedgerApi._transportType) return;\n        LedgerApi._transportType = transportType;\n        // Close api for current transport to create a new one for specified transport type on next request.\n        LedgerApi.disconnect(/* cancelRequest */ false);\n    }\n\n    public static resetTransportType() {\n        const transportType = autoDetectTransportTypeToUse();\n        if (!transportType) return;\n        LedgerApi.setTransportType(transportType);\n    }\n\n    /**\n     * Manually connect to a Ledger. Typically, this is not required as all requests establish a connection themselves.\n     * However, if that connection fails due to a required user interaction / user gesture, you can manually connect in\n     * the context of a user interaction, for example a click.\n     * @returns Whether connecting to the Ledger succeeded.\n     */\n    public static async connect(): Promise<boolean> {\n        LedgerApi._connectionAborted = false; // reset aborted flag on manual connection\n        try {\n            // Initialize the api again if it failed previously, for example due to missing user interaction.\n            await LedgerApi._initializeLowLevelApi();\n        } catch (e) {\n            // Silently continue on errors, same as the other API methods. Error was reported by _initializeLowLevelApi\n            // as error state instead. Only if user aborted the connection or browser is not supported, don't continue.\n            if (/connection aborted|not supported/i.test(e.message || e)) return false;\n        }\n        try {\n            // Use getWalletId to detect when the ledger is connected.\n            await LedgerApi.getWalletId();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Disconnect the api and clean up.\n     * @param cancelRequest - Whether to cancel an ongoing request.\n     * @param requestTypeToDisconnect - If specified, only disconnect if no request is going on or if the ongoing\n     *  request is of the specified type.\n     */\n    public static async disconnect(cancelRequest = true, requestTypeToDisconnect?: RequestType) {\n        const { currentRequest } = LedgerApi;\n        if (currentRequest) {\n            if (requestTypeToDisconnect !== undefined && currentRequest.type !== requestTypeToDisconnect) return;\n            if (cancelRequest) {\n                currentRequest.cancel();\n            }\n        }\n\n        const apiPromise = LedgerApi._lowLevelApiPromise;\n        LedgerApi._lowLevelApiPromise = null;\n        LedgerApi._currentlyConnectedWalletId = null;\n\n        if (!apiPromise) return;\n        try {\n            const api = await apiPromise;\n            await api.close();\n        } catch (e) {\n            // Ignore.\n        }\n    }\n\n    /**\n     * Get the 32 byte walletId of the currently connected ledger as base64.\n     * If no ledger is connected, it waits for one to be connected.\n     * Throws, if the request is cancelled.\n     *\n     * If currently a request to the ledger is in process, this call does not require an additional\n     * request to the Ledger. Thus, if you want to know the walletId in conjunction with another\n     * request, try to call this method after initiating the other request but before it finishes.\n     *\n     * @returns The walletId of the currently connected ledger as base 64.\n     */\n    public static async getWalletId(): Promise<string> {\n        if (LedgerApi._currentlyConnectedWalletId) return LedgerApi._currentlyConnectedWalletId;\n        // we have to wait for connection of ongoing request or initiate a call ourselves\n        if (LedgerApi.isBusy) {\n            // already a request going on. Just wait for it to connect.\n            return new Promise<string>((resolve, reject) => {\n                const onConnect = (walletId: string) => {\n                    LedgerApi.off(EventType.CONNECTED, onConnect);\n                    LedgerApi.off(EventType.REQUEST_CANCELLED, onCancel);\n                    resolve(walletId);\n                };\n                const onCancel = () => {\n                    LedgerApi.off(EventType.CONNECTED, onConnect);\n                    LedgerApi.off(EventType.REQUEST_CANCELLED, onCancel);\n                    reject(new Error('Request cancelled'));\n                };\n                LedgerApi.on(EventType.CONNECTED, onConnect);\n                LedgerApi.on(EventType.REQUEST_CANCELLED, onCancel);\n            });\n        }\n        // We have to send a request ourselves\n        const request = new LedgerApiRequest(\n            RequestType.GET_WALLET_ID,\n            // we're connected when the request get's executed\n            (): Promise<string> => Promise.resolve(LedgerApi._currentlyConnectedWalletId!),\n            {},\n        );\n        return LedgerApi._callLedger(request);\n    }\n\n    public static on(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.on(eventType, listener);\n    }\n\n    public static off(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.off(eventType, listener);\n    }\n\n    public static once(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.once(eventType, listener);\n    }\n\n    /**\n     * Convert an address's index / keyId to the full Nimiq bip32 path.\n     * @param keyId - The address's index.\n     * @returns The full bip32 path.\n     */\n    public static getBip32PathForKeyId(keyId: number): string {\n        return `${LedgerApi.BIP32_BASE_PATH}${keyId}'`;\n    }\n\n    /**\n     * Extract an address's index / keyId from its bip32 path.\n     * @param path - The address's bip32 path.\n     * @returns The address's index or null if the provided path is not a valid Nimiq key bip32 path.\n     */\n    public static getKeyIdForBip32Path(path: string): number | null {\n        const pathMatch = LedgerApi.BIP32_PATH_REGEX.exec(path);\n        if (!pathMatch) return null;\n        return parseInt(pathMatch[pathMatch.length - 1], 10);\n    }\n\n    /**\n     * Derive addresses for given bip32 key paths.\n     * @param pathsToDerive - The paths for which to derive addresses.\n     * @param [walletId] - Check that the connected wallet corresponds to the given walletId, otherwise throw. Optional.\n     * @returns The derived addresses and their corresponding key paths.\n     */\n    public static async deriveAddresses(pathsToDerive: Iterable<string>, walletId?: string)\n        : Promise<Array<{ address: string, keyPath: string }>> {\n        const request = new LedgerApiRequest(RequestType.DERIVE_ADDRESSES,\n            async (api, params): Promise<Array<{ address: string, keyPath: string }>> => {\n                const addressRecords = [];\n                for (const keyPath of params.pathsToDerive!) {\n                    if (request.cancelled) return addressRecords;\n                    // eslint-disable-next-line no-await-in-loop\n                    const { address } = await api.getAddress(\n                        keyPath,\n                        true, // validate\n                        false, // display\n                    );\n                    addressRecords.push({ address, keyPath });\n                }\n                return addressRecords;\n            },\n            {\n                walletId,\n                pathsToDerive,\n            },\n        );\n        // check paths outside of request to avoid endless loop in _callLedger if we'd throw for an invalid keyPath\n        for (const keyPath of pathsToDerive) {\n            if (LedgerApi.BIP32_PATH_REGEX.test(keyPath)) continue;\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    /**\n     * Get the public key for a given bip32 key path.\n     * @param keyPath - The path for which to derive the public key.\n     * @param [walletId] - Check that the connected wallet corresponds to the given walletId, otherwise throw. Optional.\n     * @returns The derived public key.\n     */\n    public static async getPublicKey(keyPath: string, walletId?: string): Promise<PublicKey> {\n        const request = new LedgerApiRequest(RequestType.GET_PUBLIC_KEY,\n            async (api, params): Promise<PublicKey> => {\n                const { publicKey } = await api.getPublicKey(\n                    params.keyPath!,\n                    true, // validate\n                    false, // display\n                );\n\n                // Note that the actual load of the Nimiq core and cryptography is triggered in _connect, including\n                // error handling. The call here is just used to get the reference to the Nimiq object and can not fail.\n                const Nimiq = await this._loadNimiq();\n\n                return new Nimiq.PublicKey(publicKey);\n            },\n            {\n                walletId,\n                keyPath,\n            },\n        );\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    /**\n     * Get the address for a given bip32 key path.\n     * @param keyPath - The path for which to derive the address.\n     * @param [walletId] - Check that the connected wallet corresponds to the given walletId, otherwise throw. Optional.\n     * @returns The derived address.\n     */\n    public static async getAddress(keyPath: string, walletId?: string): Promise<string> {\n        const request = new LedgerApiRequest(RequestType.GET_ADDRESS,\n            async (api, params): Promise<string> => {\n                const { address } = await api.getAddress(\n                    params.keyPath!,\n                    true, // validate\n                    false, // display\n                );\n                return address;\n            },\n            {\n                walletId,\n                keyPath,\n            },\n        );\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    /**\n     * Confirm that an address belongs to the connected Ledger and display the address to the user on the Ledger screen.\n     * @param userFriendlyAddress - The address to check.\n     * @param keyPath - The address's bip32 key path.\n     * @param [walletId] - Check that the connected wallet corresponds to the given walletId, otherwise throw. Optional.\n     * @returns The confirmed address.\n     */\n    public static async confirmAddress(userFriendlyAddress: string, keyPath: string, walletId?: string)\n        : Promise<string> {\n        const request = new LedgerApiRequest(RequestType.CONFIRM_ADDRESS,\n            async (api, params): Promise<string> => {\n                const { address: confirmedAddress } = await api.getAddress(\n                    params.keyPath!,\n                    true, // validate\n                    true, // display\n                );\n\n                if (params.addressToConfirm!.replace(/ /g, '').toUpperCase()\n                    !== confirmedAddress.replace(/ /g, '').toUpperCase()) {\n                    LedgerApi._throwError(ErrorType.REQUEST_ASSERTION_FAILED, 'Address mismatch', request);\n                }\n\n                return confirmedAddress;\n            },\n            {\n                walletId,\n                keyPath,\n                addressToConfirm: userFriendlyAddress,\n            },\n        );\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    /**\n     * Utility function that combines getAddress and confirmAddress to directly get a confirmed address.\n     * @param keyPath - The bip32 key path for which to get and confirm the address.\n     * @param [walletId] - Check that the connected wallet corresponds to the given walletId, otherwise throw. Optional.\n     * @returns The confirmed address.\n     */\n    public static async getConfirmedAddress(keyPath: string, walletId?: string): Promise<string> {\n        const address = await LedgerApi.getAddress(keyPath, walletId);\n        return this.confirmAddress(address, keyPath, walletId);\n    }\n\n    /**\n     * Sign a transaction for a signing key specified by its bip32 key path. Note that the signing key / corresponding\n     * address does not necessarily need to be the transaction's sender address for example for transactions sent from\n     * vesting contracts.\n     * @param transaction - Transaction details, see interface TransactionInfo.\n     * @param keyPath - The signing address's bip32 key path.\n     * @param [walletId] - Check that the connected wallet corresponds to the given walletId, otherwise throw. Optional.\n     * @returns The signed transaction.\n     */\n    public static async signTransaction(transaction: TransactionInfo, keyPath: string, walletId?: string)\n        : Promise<Transaction> {\n        const request = new LedgerApiRequest(RequestType.SIGN_TRANSACTION,\n            async (api, params): Promise<Transaction> => {\n                // Note: We make api calls outside of try...catch blocks to let the exceptions fall through such that\n                // _callLedger can decide how to behave depending on the api error. All other errors are converted to\n                // REQUEST_ASSERTION_FAILED errors which stop the execution of the request.\n                const { publicKey: signerPubKeyBytes } = await api.getPublicKey(\n                    params.keyPath!,\n                    true, // validate\n                    false, // display\n                );\n\n                // Note that the actual load of the Nimiq core and cryptography is triggered in _connect, including\n                // error handling. The call here is just used to get the reference to the Nimiq object and can not fail.\n                const Nimiq = await this._loadNimiq();\n\n                let nimiqTx: Transaction;\n                let signerPubKey: PublicKey;\n                try {\n                    const tx = params.transaction!;\n                    signerPubKey = new Nimiq.PublicKey(signerPubKeyBytes);\n\n                    const senderType = tx.senderType !== undefined && tx.senderType !== null\n                        ? tx.senderType\n                        : Nimiq.Account.Type.BASIC;\n\n                    const recipientType = tx.recipientType !== undefined && tx.recipientType !== null\n                        ? tx.recipientType\n                        : Nimiq.Account.Type.BASIC;\n\n                    let { network } = tx;\n                    if (!network) {\n                        try {\n                            network = Nimiq.GenesisConfig.NETWORK_NAME as 'main' | 'test' | 'dev';\n                        } catch (e) {\n                            // Genesis config not initialized\n                            network = 'main';\n                        }\n                    }\n\n                    const genesisConfig = Nimiq.GenesisConfig.CONFIGS[network];\n                    const networkId = genesisConfig.NETWORK_ID;\n\n                    const flags = tx.flags !== undefined && tx.flags !== null\n                        ? tx.flags\n                        : Nimiq.Transaction.Flag.NONE;\n                    const fee = tx.fee || 0;\n\n                    if ((tx.extraData && tx.extraData.length !== 0)\n                        || senderType !== Nimiq.Account.Type.BASIC\n                        || recipientType !== Nimiq.Account.Type.BASIC\n                        || flags !== Nimiq.Transaction.Flag.NONE\n                    ) {\n                        const extraData = tx.extraData ? tx.extraData : new Uint8Array(0);\n                        nimiqTx = new Nimiq.ExtendedTransaction(tx.sender, senderType, tx.recipient,\n                            recipientType, tx.value, fee, tx.validityStartHeight, flags, extraData,\n                            /* proof */ undefined, networkId);\n                    } else {\n                        nimiqTx = new Nimiq.BasicTransaction(signerPubKey, tx.recipient, tx.value,\n                            fee, tx.validityStartHeight, /* signature */ undefined, networkId);\n                    }\n                } catch (e) {\n                    this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, e, request);\n                }\n\n                const { signature: signatureBytes } = await api.signTransaction(\n                    params.keyPath!,\n                    nimiqTx!.serializeContent(),\n                );\n\n                try {\n                    const signature = new Nimiq.Signature(signatureBytes);\n\n                    if (nimiqTx! instanceof Nimiq.BasicTransaction) {\n                        nimiqTx.signature = signature;\n                    } else {\n                        nimiqTx!.proof = Nimiq.SignatureProof.singleSig(signerPubKey!, signature).serialize();\n                    }\n                } catch (e) {\n                    this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, e, request);\n                }\n\n                return nimiqTx!;\n            },\n            {\n                walletId,\n                keyPath,\n                transaction,\n            },\n        );\n\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    // private fields and methods\n    private static _transportType: TransportType | null = autoDetectTransportTypeToUse();\n    private static _lowLevelApiPromise: Promise<LowLevelApi> | null = null;\n    private static _currentState: State = { type: StateType.IDLE };\n    private static _currentRequest: LedgerApiRequest<any> | null = null;\n    private static _currentlyConnectedWalletId: string | null = null;\n    private static _connectionAborted: boolean = false;\n    private static _observable = new Observable();\n\n    private static async _callLedger<T>(request: LedgerApiRequest<T>): Promise<T> {\n        if (LedgerApi.isBusy) {\n            LedgerApi._throwError(ErrorType.LEDGER_BUSY, 'Only one call to Ledger at a time allowed',\n                request);\n        }\n        LedgerApi._connectionAborted = false; // user is initiating a new request\n        try {\n            LedgerApi._currentRequest = request;\n            /* eslint-disable no-await-in-loop, no-async-promise-executor */\n            return await new Promise<T>(async (resolve, reject) => {\n                let lastRequestCallTime = -1;\n                let canCancelDirectly = true;\n                let cancelFired = false;\n                request.on(LedgerApiRequest.EVENT_CANCEL, () => {\n                    // If we can, reject the call right away. Otherwise just notify that the request was requested to be\n                    // cancelled such that the user can cancel the call on the ledger.\n                    if (canCancelDirectly) {\n                        // Note that !!_currentlyConnectedWalletId is not an indicator that we can cancel directly, as\n                        // it's just an estimate and we might not actually be disconnected or the request might already\n                        // have been sent before disconnecting.\n                        if (!cancelFired) {\n                            LedgerApi._fire(EventType.REQUEST_CANCELLED, request);\n                            cancelFired = true;\n                        }\n                        reject(new Error('Request cancelled'));\n                    } else {\n                        LedgerApi._setState(StateType.REQUEST_CANCELLING);\n                    }\n                });\n                while (!request.cancelled) {\n                    try {\n                        const api = await LedgerApi._connect(request.params.walletId);\n                        if (request.cancelled) break;\n                        LedgerApi._setState(StateType.REQUEST_PROCESSING);\n                        lastRequestCallTime = Date.now();\n                        canCancelDirectly = false; // sending request which has to be resolved / cancelled by the Ledger\n                        const result = await request.call(api);\n                        if (request.cancelled) break;\n                        LedgerApi._fire(EventType.REQUEST_SUCCESSFUL, request, result);\n                        resolve(result);\n                        return;\n                    } catch (e) {\n                        console.debug(e);\n                        const message = (e.message || e || '').toLowerCase();\n                        // \"timeout\" used to happen for u2f, it's \"device_ineligible\" or \"other_error\" now (see\n                        // transport-comparison.md). \"timed out\" is for Chrome WebAuthn timeout; \"denied permission\" for\n                        // Firefox WebAuthn timeout.\n                        const isTimeout = /timeout|timed out|denied permission|u2f device_ineligible|u2f other_error/i\n                            .test(message);\n                        const isLocked = /locked|0x6804/i.test(message);\n                        const isConnectedToDashboard = /incorrect length/i.test(message);\n                        canCancelDirectly = canCancelDirectly || isTimeout || isConnectedToDashboard;\n                        if (LedgerApi._transportType === TransportType.U2F\n                            || LedgerApi._transportType === TransportType.WEB_AUTHN\n                            || isLocked) {\n                            // For u2f / webauthn we don't get notified about disconnects therefore clear connection on\n                            // every exception. When locked clear connection for all transport types as user might\n                            // unlock with a different PIN for another wallet.\n                            LedgerApi._currentlyConnectedWalletId = null;\n                        }\n                        // Test whether user cancelled call on ledger device or in WebAuthn / U2F browser popup\n                        if (message.indexOf('denied by the user') !== -1 // user rejected confirmAddress on device\n                            || message.indexOf('request was rejected') !== -1 // user rejected signTransaction on device\n                            || LedgerApi._isWebAuthnOrU2fCancellation(message, lastRequestCallTime)) {\n                            // Note that on _isWebAuthnOrU2fCancellation we can cancel directly and don't need the user\n                            // to cancel the request on the device as Ledger Nano S is now able to clean up old WebAuthn\n                            // and U2F requests and the the Nano X lets the Nimiq App crash anyways after the WebAuthn /\n                            // U2F host was lost.\n                            canCancelDirectly = true;\n                            request.cancel(); // in case the request was not marked as cancelled before\n                            break; // continue after loop where the actual cancellation happens\n                        }\n                        // Errors that should end the request\n                        if ((LedgerApi.currentState.error\n                            && LedgerApi.currentState.error.type === ErrorType.REQUEST_ASSERTION_FAILED)\n                            || message.indexOf('not supported') !== -1) { // no browser support\n                            reject(e);\n                            return;\n                        }\n                        // On other errors try again\n                        if (!/busy|outdated|connection aborted|user gesture|dependencies|wrong ledger/i.test(message)\n                            && !isTimeout && !isLocked && !isConnectedToDashboard) {\n                            console.warn('Unknown Ledger Error', e);\n                        }\n                        // Wait a little when replacing a previous U2F request (see transport-comparison.md).\n                        const waitTime = isTimeout ? LedgerApi.WAIT_TIME_AFTER_TIMEOUT\n                            // If the API tells us that the ledger is busy (see transport-comparison.md) use a longer\n                            // wait time to reduce the chance that we hit unfortunate 1.5s window after timeout of\n                            // cancelled call\n                            : message.indexOf('busy') !== -1 ? 4 * LedgerApi.WAIT_TIME_AFTER_TIMEOUT\n                                // For other exceptions wait a little to avoid busy endless loop for some exceptions.\n                                : LedgerApi.WAIT_TIME_AFTER_ERROR;\n                        await new Promise((resolve2) => setTimeout(resolve2, waitTime));\n                    }\n                }\n                if (!cancelFired) {\n                    LedgerApi._fire(EventType.REQUEST_CANCELLED, request);\n                    cancelFired = true;\n                }\n                reject(new Error('Request cancelled'));\n            });\n            /* eslint-enable no-await-in-loop, no-async-promise-executor */\n        } finally {\n            LedgerApi._currentRequest = null;\n            if (LedgerApi._transportType === TransportType.U2F\n                || LedgerApi._transportType === TransportType.WEB_AUTHN) {\n                LedgerApi._currentlyConnectedWalletId = null; // reset as we don't note when Ledger gets disconnected\n            }\n            const errorType = LedgerApi.currentState.error ? LedgerApi.currentState.error.type : null;\n            if (errorType !== ErrorType.NO_BROWSER_SUPPORT\n                && errorType !== ErrorType.REQUEST_ASSERTION_FAILED) {\n                LedgerApi._setState(StateType.IDLE);\n            }\n        }\n    }\n\n    private static async _connect(walletId?: string): Promise<LowLevelApi> {\n        // Resolves when connected to unlocked ledger with open Nimiq app otherwise throws an exception after timeout,\n        // in contrast to the public connect method which uses getWalletId to listen for a connection or to try to\n        // connect repeatedly until success via _callLedger which uses the private _connect under the hood. Also this\n        // method is not publicly exposed to avoid that it could be invoked multiple times in parallel which the ledger\n        // requests called here do not allow. Additionally, this method exposes the low level api which is private.\n        if (LedgerApi._connectionAborted) {\n            // When the connection was aborted, don't retry connecting until a manual connection is requested.\n            throw new Error('Connection aborted');\n        }\n\n        const nimiqPromise = this._loadNimiq();\n        const api = await LedgerApi._initializeLowLevelApi();\n\n        // Establish / verify the connection.\n        // This takes <300ms for a pre-authorized device via WebUSB, WebHID or WebBLE and <1s for WebAuthn or U2F.\n        if (!LedgerApi._currentlyConnectedWalletId) {\n            const connectStart = Date.now();\n            LedgerApi._setState(StateType.CONNECTING);\n\n            let firstAddressPubKeyBytes: Uint8Array;\n            let version: string;\n            try {\n                // To check whether the connection to Nimiq app is established and to calculate the walletId. Set\n                // validate to false as otherwise the call is much slower. For U2F this can also unfreeze the ledger\n                // app, see transport-comparison.md. Using getPublicKey and not getAppConfiguration, as other apps also\n                // respond to getAppConfiguration (for example the Ethereum app).\n                ({ publicKey: firstAddressPubKeyBytes } = await api.getPublicKey(\n                    LedgerApi.getBip32PathForKeyId(0),\n                    false, // validate\n                    false, // display\n                ));\n                ({ version } = await api.getAppConfiguration());\n            } catch (e) {\n                const message = (e.message || e || '').toLowerCase();\n                if (message.indexOf('busy') !== -1) {\n                    LedgerApi._throwError(ErrorType.LEDGER_BUSY, e);\n                } else if (LedgerApi._isWebAuthnOrU2fCancellation(message, connectStart)) {\n                    LedgerApi._connectionAborted = true;\n                    LedgerApi._throwError(ErrorType.CONNECTION_ABORTED, `Connection aborted: ${message}`);\n                }\n\n                // Just rethrow other errors that just keep the API retrying (like timeout, dongle locked).\n                throw e;\n            }\n\n            if (!LedgerApi._isAppVersionSupported(version)) {\n                LedgerApi._throwError(ErrorType.APP_OUTDATED, 'Ledger Nimiq App is outdated.');\n            }\n\n            try {\n                const Nimiq = await nimiqPromise;\n                // Use sha256 as blake2b yields the nimiq address\n                LedgerApi._currentlyConnectedWalletId = Nimiq.Hash.sha256(firstAddressPubKeyBytes).toBase64();\n            } catch (e) {\n                LedgerApi._throwError(ErrorType.LOADING_DEPENDENCIES_FAILED,\n                    `Failed loading dependencies: ${e.message || e}`);\n            }\n        }\n\n        if (walletId !== undefined && LedgerApi._currentlyConnectedWalletId !== walletId) {\n            LedgerApi._throwError(ErrorType.WRONG_LEDGER, 'Wrong Ledger connected');\n        }\n        this._fire(EventType.CONNECTED, LedgerApi._currentlyConnectedWalletId);\n        return api;\n    }\n\n    private static async _initializeLowLevelApi(): Promise<LowLevelApi> {\n        const transportType = LedgerApi._transportType;\n        LedgerApi._lowLevelApiPromise = LedgerApi._lowLevelApiPromise || (async () => {\n            // Check browser support for current transport. Note that when transport changes during connect, we recurse.\n            if (!transportType || !isSupported(transportType)) {\n                LedgerApi._throwError(ErrorType.NO_BROWSER_SUPPORT,\n                    'Ledger not supported by browser or support not enabled.');\n            }\n\n            // Load transport lib.\n            let TransportLib: TransportWebUsbConstructor | TransportConstructor;\n            // Only set the loading state if the lib is not already loaded or fails instantly.\n            const delayedLoadingStateTimeout = setTimeout(() => LedgerApi._setState(StateType.LOADING), 50);\n            try {\n                TransportLib = await loadTransportLibrary(transportType!);\n            } catch (e) {\n                if (transportType === LedgerApi._transportType) {\n                    LedgerApi._throwError(ErrorType.LOADING_DEPENDENCIES_FAILED,\n                        `Failed loading dependencies: ${e.message || e}`);\n                }\n            } finally {\n                clearTimeout(delayedLoadingStateTimeout);\n            }\n            if (transportType !== LedgerApi._transportType) throw new Error('Transport changed');\n\n            // Create transport. Note that creating the transport has to happen in the context of a user interaction if\n            // opening a device selector is required.\n            let transport: InstanceType<typeof TransportLib>;\n            // Only set the connecting state if it is not instantaneous because a device selector needs to be shown\n            const delayedConnectingStateTimeout = setTimeout(() => LedgerApi._setState(StateType.CONNECTING), 50);\n            try {\n                transport = await TransportLib!.create();\n            } catch (e) {\n                if (transportType === LedgerApi._transportType) {\n                    const message = (e.message || e).toLowerCase();\n                    if (/no device selected|access denied|cancelled the requestdevice/i.test(message)) {\n                        if (LedgerApi._transportType === TransportType.WEB_USB) {\n                            // Use a fallback as the user might not have been able to select his device due to the Nano\n                            // X currently not being discoverable via WebUSB in Windows.\n                            // This fallback also temporarily serves Linux users which have not updated their udev rules\n                            // TODO the fallback is just temporary and to be removed once WebUSB with Nano X works on\n                            //  Windows or WebHID is more broadly available.\n                            const fallback = [TransportType.WEB_AUTHN, TransportType.U2F].find(isSupported);\n                            if (!fallback) {\n                                LedgerApi._throwError(ErrorType.NO_BROWSER_SUPPORT,\n                                    'Ledger not supported by browser or support not enabled.');\n                            }\n                            console.warn(`LedgerApi: switching to ${fallback} as fallback`);\n                            LedgerApi.setTransportType(fallback!);\n                        } else {\n                            LedgerApi._connectionAborted = true;\n                            LedgerApi._throwError(ErrorType.CONNECTION_ABORTED, `Connection aborted: ${message}`);\n                        }\n                    } else if (message.indexOf('user gesture') !== -1) {\n                        LedgerApi._throwError(ErrorType.USER_INTERACTION_REQUIRED, e);\n                    } else {\n                        throw e; // rethrow unknown exception\n                    }\n                }\n            } finally {\n                clearTimeout(delayedConnectingStateTimeout);\n            }\n            if (transportType !== LedgerApi._transportType) {\n                transport!.close();\n                throw new Error('Transport changed');\n            }\n\n            const onDisconnect = () => {\n                console.debug('Ledger disconnected');\n                transport.off('disconnect', onDisconnect);\n                if (transportType === LedgerApi._transportType) {\n                    // Disconnected transport cannot be reconnected. Thus also disconnect from our side for cleanup.\n                    // If the transport switched, no additional cleanup is necessary as it already happened on switch.\n                    LedgerApi.disconnect(/* cancelRequest */ false);\n                }\n            };\n            transport!.on('disconnect', onDisconnect);\n\n            return new LowLevelApi(transport!);\n        })();\n\n        try {\n            return await LedgerApi._lowLevelApiPromise;\n        } catch (e) {\n            LedgerApi._lowLevelApiPromise = null;\n            if (transportType === LedgerApi._transportType) throw e;\n            // Transport type changed while we were connecting; ignore error and rerun\n            return LedgerApi._initializeLowLevelApi();\n        }\n    }\n\n    private static async _loadNimiq(): Promise<Nimiq> {\n        // Note that we don't need to cache a promise here as loadNimiqCore and loadNimiqCryptography already do that.\n        const [Nimiq] = await Promise.all([\n            loadNimiqCore(),\n            // needed for walletId hashing and pub key to address derivation in SignatureProof and BasicTransaction\n            loadNimiqCryptography(),\n        ]);\n        return Nimiq;\n    }\n\n    private static _isWebAuthnOrU2fCancellation(errorMessage: string, requestStart: number) {\n        // Try to detect a WebAuthn or U2F cancellation. In Firefox, we can detect a WebAuthn cancellation for the\n        // Firefox internal popup. However, Firefox U2F cancellations, Firefox WebAuthn cancellations via Window's\n        // native popup and Chrome WebAuthn cancellations are not distinguishable from timeouts, therefore we check\n        // how likely it is a timeout by the passed time since request start.\n        return /operation was aborted/i.test(errorMessage) // WebAuthn cancellation in Firefox internal popup\n            || (/timed out|denied permission|u2f other_error/i.test(errorMessage) && Date.now() - requestStart < 20000);\n    }\n\n    private static _isAppVersionSupported(versionString: string): boolean {\n        const version = versionString.split('.').map((part) => parseInt(part, 10));\n        for (let i = 0; i < LedgerApi.MIN_REQUIRED_APP_VERSION.length; ++i) {\n            if (typeof version[i] === 'undefined' || version[i] < LedgerApi.MIN_REQUIRED_APP_VERSION[i]) return false;\n            if (version[i] > LedgerApi.MIN_REQUIRED_APP_VERSION[i]) return true;\n        }\n        return true;\n    }\n\n    private static _setState(state: State | StateType): void {\n        if (typeof state === 'string') {\n            // it's an entry from LedgerApi.StateType enum\n            state = { type: state };\n        }\n        state.request = !state.request && LedgerApi._currentRequest ? LedgerApi._currentRequest : state.request;\n\n        if (LedgerApi._currentState.type === state.type\n            && (LedgerApi._currentState.error === state.error\n                || (!!LedgerApi._currentState.error && !!state.error\n                    && LedgerApi._currentState.error.type === state.error.type))\n            && LedgerApi._currentState.request === state.request) return;\n        LedgerApi._currentState = state;\n        LedgerApi._fire(EventType.STATE_CHANGE, state);\n    }\n\n    private static _throwError(\n        type: ErrorType,\n        error: Error | string,\n        request?: LedgerApiRequest<any>,\n    ): void {\n        const state: State = {\n            type: StateType.ERROR,\n            error: {\n                type,\n                message: typeof error === 'string' ? error : error.message,\n            },\n        };\n        if (request) state.request = request;\n        LedgerApi._setState(state);\n        if (typeof error === 'string') {\n            throw new Error(error);\n        } else {\n            throw error;\n        }\n    }\n\n    private static _fire(eventName: EventType, ...args: any[]): void {\n        LedgerApi._observable.fire(eventName, ...args);\n    }\n}\n"],"names":[],"mappings":"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"}