{"version":3,"file":"ledger-api.es.js","sources":["source-mapped://source-mapped/src/lib/load-nimiq.ts","source-mapped://source-mapped/src/low-level-api/low-level-api-utils.ts","source-mapped://source-mapped/src/low-level-api/low-level-api.ts","source-mapped://source-mapped/src/lib/observable.ts","source-mapped://source-mapped/src/high-level-api/transport-utils.ts","source-mapped://source-mapped/src/high-level-api/ledger-api-request.ts","source-mapped://source-mapped/src/high-level-api/ledger-api.ts"],"sourcesContent":["type Nimiq = typeof import('@nimiq/core-web');\n\nconst coreBasePath = 'https://cdn.nimiq.com/latest/';\n\nlet nimiqCorePromise: Promise<Nimiq> | null = null;\n\n/**\n * Lazy-load the Nimiq core api from the cdn server if it's not loaded yet.\n */\nexport async function loadNimiqCore(coreVariant: 'web' | 'web-offline' = 'web-offline'): Promise<Nimiq> {\n    // @ts-ignore Return global Nimiq if already loaded.\n    if (window.Nimiq) return window.Nimiq;\n\n    nimiqCorePromise = nimiqCorePromise || new Promise((resolve, reject) => {\n        const $head = document.getElementsByTagName('head')[0];\n        const $script = document.createElement('script');\n        $script.type = 'text/javascript';\n        $script.onload = () => {\n            $script.parentNode!.removeChild($script);\n            resolve();\n        };\n        $script.onerror = (e) => {\n            $script.parentNode!.removeChild($script);\n            reject(e);\n        };\n        $script.src = `${coreBasePath}${coreVariant}.js`;\n        $head.appendChild($script);\n    }).then(\n        () => {\n            // @ts-ignore Nimiq is global but to discourage usage as global var we did not declare a global type.\n            const { Nimiq } = window;\n            return Nimiq;\n        },\n        (e) => {\n            nimiqCorePromise = null;\n            return Promise.reject(e);\n        },\n    );\n    return nimiqCorePromise;\n}\n\n/**\n * Load the WebAssembly and module for cryptographic functions. You will have to do this before calculating hashes,\n * deriving keys or addresses, signing transactions or messages, etc.\n */\nexport async function loadNimiqCryptography(): Promise<void> {\n    // Note that there is no need to cache a promise like in loadNimiqCore for this call, as loadNimiqCore and doImport\n    // already do that themselves.\n    const Nimiq = await loadNimiqCore();\n    await Nimiq.WasmHelper.doImport();\n}\n","import { loadNimiqCore, loadNimiqCryptography } from '../lib/load-nimiq';\n\nexport function parsePath(path: string): Buffer {\n    if (!path.startsWith('44\\'/242\\'')) {\n        throw new Error(\n            `Not a Nimiq BIP32 path. Path: ${path}. The Nimiq app is authorized only for paths starting with 44'/242'. `\n            + ' Example: 44\\'/242\\'/0\\'/0\\'',\n        );\n    }\n\n    const pathParts: number[] = path.split('/').map((part) => {\n        let number = parseInt(part, 10);\n        if (Number.isNaN(number)) {\n            throw new Error(`Invalid path: ${path}`);\n        }\n        if (part.endsWith('\\'')) {\n            number += 0x80000000;\n        } else {\n            throw new Error(\n                'Detected a non-hardened path element in requested BIP32 path.'\n                + ' Non-hardended paths are not supported at this time. Please use an all-hardened path.'\n                + ' Example: 44\\'/242\\'/0\\'/0\\'',\n            );\n        }\n        return number;\n    });\n\n    const pathBuffer = Buffer.alloc(1 + pathParts.length * 4);\n    pathBuffer[0] = pathParts.length;\n    pathParts.forEach((element, index) => {\n        pathBuffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return pathBuffer;\n}\n\nexport async function publicKeyToAddress(publicKey: Buffer): Promise<string> {\n    const [Nimiq] = await Promise.all([\n        loadNimiqCore(),\n        loadNimiqCryptography(), // needed for hashing public key to an address\n    ]);\n    return Nimiq.PublicKey.unserialize(new Nimiq.SerialBuffer(publicKey)).toAddress().toUserFriendlyAddress();\n}\n\nexport async function verifySignature(\n    data: Buffer,\n    signature: Buffer,\n    publicKey: Buffer,\n): Promise<boolean> {\n    const [Nimiq] = await Promise.all([loadNimiqCore(), loadNimiqCryptography()]);\n    const nimiqSignature = Nimiq.Signature.unserialize(new Nimiq.SerialBuffer(signature));\n    const nimiqPublicKey = Nimiq.PublicKey.unserialize(new Nimiq.SerialBuffer(publicKey));\n    return nimiqSignature.verify(nimiqPublicKey, data);\n}\n","import {\n    parsePath,\n    publicKeyToAddress,\n    verifySignature,\n} from './low-level-api-utils';\nimport { loadNimiqCore, loadNimiqCryptography } from '../lib/load-nimiq';\n\ntype Transport = import('@ledgerhq/hw-transport').default;\n\nconst CLA = 0xe0;\nconst INS_GET_PK = 0x02;\nconst INS_SIGN_TX = 0x04;\nconst INS_GET_CONF = 0x06;\nconst INS_KEEP_ALIVE = 0x08;\n\nconst APDU_MAX_SIZE = 150;\nconst P1_FIRST_APDU = 0x00;\nconst P1_MORE_APDU = 0x80;\nconst P1_NO_VALIDATE = 0x00;\nconst P1_VALIDATE = 0x01;\nconst P2_LAST_APDU = 0x00;\nconst P2_MORE_APDU = 0x80;\nconst P2_NO_CONFIRM = 0x00;\nconst P2_CONFIRM = 0x01;\n\nconst SW_OK = 0x9000;\nconst SW_CANCEL = 0x6985;\nconst SW_KEEP_ALIVE = 0x6e02;\n\n// The @ledgerhq libraries use Node Buffers which need to be polyfilled in the browser. To avoid the need to bundle such\n// polyfills that an app likely already has bundled in the @ledgerhq libraries, this library expects a global polyfill\n// declared on window.\ndeclare global {\n    interface Window {\n        Buffer?: typeof Buffer;\n    }\n}\n\n/**\n * Nimiq API\n *\n * Low level api for communication with the Ledger wallet Nimiq app. This lib is compatible with all @ledgerhq/transport\n * libraries but does on the other hand not include optimizations for specific transport types and returns raw bytes.\n *\n * This library is in nature similar to other hw-app packages in @ledgerhq/ledgerjs and partially based on their code,\n * licenced under the Apache 2.0 licence.\n *\n * @example\n * const nim = new LowLevelApi(transport)\n */\nexport default class LowLevelApi {\n    private _transport: Transport;\n\n    constructor(transport: Transport) {\n        this._transport = transport;\n        transport.decorateAppAPIMethods(\n            this,\n            ['getAppConfiguration', 'getPublicKey', 'signTransaction'],\n            'w0w',\n        );\n    }\n\n    /**\n     * Close the transport instance. Note that this does not emit a disconnect. Disconnects are only emitted when the\n     * device actually disconnects (or switches it's descriptor which happens when switching to the dashboard or apps).\n     */\n    public close() {\n        try {\n            this._transport.close();\n        } catch (e) {\n            // Ignore. Transport might already be closed.\n        }\n    }\n\n    /**\n     * Get the version of the connected Ledger Nimiq App. Note that some other apps like the Ethereum app also respond\n     * to this call.\n     */\n    public async getAppConfiguration(): Promise<{ version: string }> {\n        // Note that no heartbeat is required here as INS_GET_CONF is not interactive but thus answers directly\n        const [, major, minor, patch] = await this._transport.send(CLA, INS_GET_CONF, 0x00, 0x00);\n        const version = `${major}.${minor}.${patch}`;\n        return { version };\n    }\n\n    /**\n     * Get Nimiq address for a given BIP 32 path.\n     * @param path - A path in BIP 32 format.\n     * @param boolValidate - Optionally enable key pair validation.\n     * @param boolDisplay - Optionally display the address on the ledger.\n     * @returns An object with the address\n     * @example\n     * nim.getAddress(\"44'/242'/0'/0'\").then(o => o.address)\n     */\n    public async getAddress(\n        path: string,\n        boolValidate: boolean = true,\n        boolDisplay: boolean = false,\n    ): Promise<{ address: string }> {\n        // start loading Nimiq core later needed for transforming public key to address and optional validation\n        loadNimiqCore();\n        loadNimiqCryptography();\n\n        const { publicKey } = await this.getPublicKey(path, boolValidate, boolDisplay);\n        const address = await publicKeyToAddress(Buffer.from(publicKey));\n        return { address };\n    }\n\n    /**\n     * Get Nimiq public key for a given BIP 32 path.\n     * @param path - A path in BIP 32 format.\n     * @param boolValidate - Optionally enable key pair validation.\n     * @param boolDisplay - Optionally display the corresponding address on the ledger.\n     * @returns An object with the publicKey\n     * @example\n     * nim.getPublicKey(\"44'/242'/0'/0'\").then(o => o.publicKey)\n     */\n    public async getPublicKey(\n        path: string,\n        boolValidate: boolean = true,\n        boolDisplay: boolean = false,\n    ): Promise<{ publicKey: Uint8Array }> {\n        if (boolValidate) {\n            // start loading Nimiq core later needed for validation\n            loadNimiqCore();\n            loadNimiqCryptography();\n        }\n\n        const pathBuffer = parsePath(path);\n        const verifyMsg = Buffer.from('p=np?', 'ascii');\n        const data = Buffer.concat([pathBuffer, verifyMsg]);\n\n        let response: Buffer;\n        response = await this._transport.send(\n            CLA,\n            INS_GET_PK,\n            boolValidate ? P1_VALIDATE : P1_NO_VALIDATE,\n            boolDisplay ? P2_CONFIRM : P2_NO_CONFIRM,\n            data,\n            [SW_OK, SW_KEEP_ALIVE],\n        );\n        // handle heartbeat\n        while (response.slice(response.length - 2).readUInt16BE(0) === SW_KEEP_ALIVE) {\n            // eslint-disable-next-line no-await-in-loop\n            response = await this._transport.send(CLA, INS_KEEP_ALIVE, 0, 0, undefined, [SW_OK, SW_KEEP_ALIVE]);\n        }\n\n        let offset = 0;\n        const publicKey = response.slice(offset, offset + 32);\n        offset += 32;\n        if (boolValidate) {\n            const signature = response.slice(offset, offset + 64);\n            if (!await verifySignature(verifyMsg, signature, publicKey)) {\n                throw new Error(\n                    'Bad signature. Keypair is invalid. Please report this.',\n                );\n            }\n        }\n        return { publicKey };\n    }\n\n    /**\n     * Sign a Nimiq transaction.\n     * @param path - A path in BIP 32 format.\n     * @param txContent - Transaction content in serialized form.\n     * @returns An object with the signature\n     * @example\n     * nim.signTransaction(\"44'/242'/0'/0'\", signatureBase).then(o => o.signature)\n     */\n    public async signTransaction(\n        path: string,\n        txContent: Uint8Array,\n    ): Promise<{ signature: Uint8Array }> {\n        const pathBuffer = parsePath(path);\n        const transaction = Buffer.from(txContent);\n        const apdus = [];\n        let chunkSize = APDU_MAX_SIZE - pathBuffer.length;\n        if (transaction.length <= chunkSize) {\n            // it fits in a single apdu\n            apdus.push(Buffer.concat([pathBuffer, transaction]));\n        } else {\n            // we need to send multiple apdus to transmit the entire transaction\n            let chunk = Buffer.alloc(chunkSize);\n            let offset = 0;\n            transaction.copy(chunk, 0, offset, chunkSize);\n            apdus.push(Buffer.concat([pathBuffer, chunk]));\n            offset += chunkSize;\n            while (offset < transaction.length) {\n                const remaining = transaction.length - offset;\n                chunkSize = remaining < APDU_MAX_SIZE ? remaining : APDU_MAX_SIZE;\n                chunk = Buffer.alloc(chunkSize);\n                transaction.copy(chunk, 0, offset, offset + chunkSize);\n                offset += chunkSize;\n                apdus.push(chunk);\n            }\n        }\n\n        let isHeartbeat = false;\n        let chunkIndex = 0;\n        let status: number;\n        let response: Buffer;\n        do {\n            const data = apdus[chunkIndex];\n            // eslint-disable-next-line no-await-in-loop\n            response = await this._transport.send(\n                CLA,\n                isHeartbeat ? INS_KEEP_ALIVE : INS_SIGN_TX,\n                chunkIndex === 0 ? P1_FIRST_APDU : P1_MORE_APDU, // note that for heartbeat p1, p2 and data are ignored\n                chunkIndex === apdus.length - 1 ? P2_LAST_APDU : P2_MORE_APDU,\n                data,\n                [SW_OK, SW_CANCEL, SW_KEEP_ALIVE],\n            );\n            status = response.slice(response.length - 2).readUInt16BE(0);\n            isHeartbeat = status === SW_KEEP_ALIVE;\n            if (!isHeartbeat) {\n                // we can continue sending data or end the loop when all data was sent\n                ++chunkIndex;\n            }\n        } while (isHeartbeat || chunkIndex < apdus.length);\n\n        if (status !== SW_OK) throw new Error('Transaction approval request was rejected');\n        const signature = Buffer.from(response.slice(0, response.length - 2));\n        return {\n            signature: Uint8Array.from(signature),\n        };\n    }\n}\n","export type EventListener = (...args: any[]) => void;\n\nexport default class Observable {\n    private _listeners: Map<string, EventListener[]> = new Map();\n\n    public on(eventType: string, listener: EventListener): void {\n        if (!this._listeners.has(eventType)) {\n            this._listeners.set(eventType, [listener]);\n        } else {\n            this._listeners.get(eventType)!.push(listener);\n        }\n    }\n\n    public off(eventType: string, listener: EventListener): void {\n        const listenersForEvent = this._listeners.get(eventType);\n        if (!listenersForEvent) return;\n        const index = listenersForEvent.indexOf(listener);\n        if (index === -1) return;\n        listenersForEvent.splice(index, 1);\n    }\n\n    public once(eventType: string, listener: EventListener): void {\n        const onceListener: EventListener = ((...args: any[]) => {\n            this.off(eventType, onceListener);\n            listener(...args);\n        });\n        this.on(eventType, onceListener);\n    }\n\n    public fire(eventName: string, ...args: any[]): void {\n        // Let current micro task finish before invoking listeners\n        setTimeout(() => {\n            const listenersForEvent = this._listeners.get(eventName);\n            if (!listenersForEvent) return;\n            for (const listener of listenersForEvent) {\n                listener(...args);\n            }\n        }, 0);\n    }\n}\n","type Transport = import('@ledgerhq/hw-transport').default;\n\nexport enum TransportType {\n    WEB_HID = 'web-hid',\n    WEB_USB = 'web-usb',\n    WEB_BLE = 'web-ble',\n    U2F = 'u2f',\n}\n\nexport function isSupported(transportType?: TransportType): boolean {\n    if (window.location.protocol !== 'https:') return false;\n    if (!transportType) return !!autoDetectTransportTypeToUse();\n    // inspired by @ledgerhq/hw-transport libs\n    switch (transportType) {\n        case TransportType.WEB_HID:\n            return 'hid' in window.navigator;\n        case TransportType.WEB_USB:\n            // @ts-ignore\n            return 'usb' in window.navigator && typeof window.navigator.usb.getDevices === 'function';\n        case TransportType.WEB_BLE:\n            return 'bluetooth' in window.navigator;\n        case TransportType.U2F:\n            // Note that Chrome, Opera and Edge use an internal, hidden cryptotoken extension to handle u2f\n            // (https://github.com/google/u2f-ref-code/blob/master/u2f-gae-demo/war/js/u2f-api.js) which does not\n            // expose an u2f api on window. Support via that extension is not detected by this check. However, as\n            // these browsers support WebUsb, this is acceptable.\n            // @ts-ignore\n            return 'u2f' in window && typeof window.u2f.sign === 'function';\n        default:\n            return false;\n    }\n}\n\nexport function autoDetectTransportTypeToUse(): TransportType | null {\n    // Determine the best available transport type. Exclude WebBle as it's only suitable for Nano X.\n    return [\n        // TODO according to Ledger, HID has better compatibility on windows due to driver issues for WebUSB. Need to\n        //  test and investigate that claim. On Linux however, WebUSB is preferable for multiple reasons (Chrome):\n        //  - Currently HID permission is only valid until device is disconnected while WebUSB remembers a granted\n        //    permission. This results in a device selection popup every time the Ledger is reconnected (or changes to\n        //    another app or the dashboard, where Ledger reports different device descriptors, i.e. appears as a\n        //    different device). This also requires a user gesture every time.\n        //  - HID device selection popup does not update on changes, for example on switch from Ledger dashboard to app\n        //    or when Ledger gets connected.\n        //  - HID does not emit disconnects immediately but only at next request.\n        TransportType.WEB_USB, // WebUSB preferred over WebHID because of reasons stated above\n        TransportType.WEB_HID, // WebHID preferred over U2F because U2F can time out and causes popups in Windows\n        TransportType.U2F, // U2F as legacy fallback\n    ].find(isSupported) || null;\n}\n\n/**\n * Create a new transport to a connected Ledger device. All transport types but U2F must be invoked on user interaction.\n * If an already known device is connected, a transport instance to that device is established. Otherwise, a browser\n * popup with a selector is opened.\n * @param transportType\n */\nexport async function createTransport(transportType: TransportType): Promise<Transport> {\n    switch (transportType) {\n        case TransportType.WEB_HID:\n            return (await import('@ledgerhq/hw-transport-webhid')).default.create();\n        case TransportType.WEB_USB:\n            return (await import('@ledgerhq/hw-transport-webusb')).default.create();\n        case TransportType.WEB_BLE:\n            return (await import('@ledgerhq/hw-transport-web-ble')).default.create();\n        case TransportType.U2F:\n            return (await import('@ledgerhq/hw-transport-u2f')).default.create();\n        default:\n            throw new Error(`Unknown transport type ${transportType}`);\n    }\n}\n","import Observable, { EventListener } from '../lib/observable';\n\ntype LowLevelApi = import('../low-level-api/low-level-api').default;\ntype TransactionInfo = import('./ledger-api').TransactionInfo;\n\nexport enum RequestType {\n    GET_WALLET_ID = 'get-wallet-id',\n    DERIVE_ADDRESSES = 'derive-addresses',\n    GET_PUBLIC_KEY = 'get-public-key',\n    GET_ADDRESS = 'get-address',\n    CONFIRM_ADDRESS = 'confirm-address',\n    SIGN_TRANSACTION = 'sign-transaction',\n}\n\nexport interface RequestParams {\n    walletId?: string; // optional for all calls\n    keyPath?: string; // for everything besides DERIVE_ADDRESSES\n    pathsToDerive?: Iterable<string>; // for DERIVE_ADDRESSES\n    addressToConfirm?: string; // for CONFIRM_TRANSACTION\n    transaction?: TransactionInfo; // for SIGN_TRANSACTION\n}\n\nexport default class LedgerApiRequest<T> extends Observable {\n    public static readonly EVENT_CANCEL = 'cancel';\n    public readonly type: RequestType;\n    public readonly params: RequestParams;\n    private readonly _call: (api: LowLevelApi, params: RequestParams) => Promise<T>;\n    private _cancelled: boolean = false;\n\n    constructor(\n        type: RequestType,\n        call: (api: LowLevelApi, params: RequestParams) => Promise<T>,\n        params: RequestParams,\n    ) {\n        super();\n        this.type = type;\n        this._call = call;\n        this.params = params;\n    }\n\n    public get cancelled(): boolean {\n        return this._cancelled;\n    }\n\n    public async call(api: LowLevelApi): Promise<T> {\n        return this._call.call(this, api, this.params);\n    }\n\n    public cancel(): void {\n        this._cancelled = true;\n        this.fire(LedgerApiRequest.EVENT_CANCEL);\n    }\n\n    public on(type: string, callback: EventListener): void {\n        if (type === LedgerApiRequest.EVENT_CANCEL && this._cancelled) {\n            // trigger callback directly\n            callback();\n        }\n        return super.on(type, callback);\n    }\n}\n","// Some notes about the behaviour of the ledger:\n// - The ledger only supports one call at a time.\n// - If the browser doesn't support U2F, an exception gets thrown (\"U2F browser support is needed for Ledger\")\n// - The browsers U2F API has a timeout after which the call fails in the browser. The timeout is about 30s.\n// - Previously, a \"timeout\" exception got thrown on u2f timeouts, but now it's generic \"U2F DEVICE_INELIGIBLE\" in\n//   Chrome and \"U2F OTHER_ERROR\" in Firefox.\n// - The Nimiq Ledger App avoids timeouts by keeping the call alive via a heartbeat when the Ledger is connected and the\n//   app opened. However when the Ledger is not connected or gets disconnected, timeouts still occur.\n// - If the ledger is locked while the nimiq app (or another app throwing that same exception) was running, an exception\n//   gets thrown. The error code for this was 0x6982 before and got translated to a \"dongle locked\" error, but this\n//   seems to have changed. Get public key / address requests now throw a 0x6804 UNKNOWN_ERROR; other requests don't\n//   throw and just stay pending until unlocked. No exception gets thrown when the Ledger is locked on the dashboard or\n//   locked when just being connected. getAppConfiguration can be called even when the app is locked.\n// - If the ledger is busy with another call it throws an exception that it is busy. The ledger API however only knows,\n//   if the ledger is busy by another call from this same page (and same API instance?).\n// - If we make another call while the other call is still ongoing and the ledger not detected as being busy, the\n//   heartbeat breaks and a timeout occurs.\n// - Requests that were cancelled via request.cancel() are not actually cancelled on the ledger and keep the ledger\n//   busy until the request times out or the user confirms/declines.\n//\n// Notes about app versions < 1.4.3 (?) or older firmwares:\n// - If the ledger locks during a signTransaction request and the \"dongle locked\" exception gets thrown after some while\n//   and the user then unlocks the ledger again, the request data is gone or not displayed (amount, recipient, fee,\n//   network, extra data etc). If the user then rejects/confirms, the ledger freezes and can not be unfrozen. This did\n//   not occur with this api, as we replaced that call after unlock. That behavior has now been removed though, as it's\n//   not relevant for newer versions anymore.\n//\n// Notes about app versions < 1.4.1 / 1.4.0:\n// - App versions < 1.4.0 are incompatible with Chrome 72+, see https://github.com/LedgerHQ/ledgerjs/issues/306.\n// - App versions < 1.4.1 are incompatible with Chrome 72-73\n//\n// Notes about app versions < 1.3.1:\n// - Versions < 1.3.1 did not have a heartbeat to avoid timeouts\n// - For requests with display on the ledger, the ledger keeps displaying the request even if it timed out. When the\n//   user confirms or declines that request after the timeout the ledger ignores that and freezes on second press.\n// - After a request timed out, it is possible to send a new request to the ledger essentially replacing the old\n//   request. If the ledger is still displaying the UI from the previous timed out request and the new request also has\n//   a UI, the old UI also gets replaced. The animation of the new request starts at the beginning.\n// - Although a previous request can be replaced immediately after the timeout exception (no device busy exception gets\n//   thrown and the UI gets replaced), the buttons still seem to be assigned to the previous request if there is no\n//   wait time between the requests. Wait time <1s is too short. Wait times between 1s and 1.5s behave strange as the\n//   old request doesn't get replaced at all. 1.5s seems to be reliable. At that time, the signTransaction UI also\n//   forms a nice loop with the replaced UI.\n// - If the user confirms or declines during the wait time nothing happens (or freeze at second button press) which\n//   is a bad user experience but there is nothing we can do about it.\n// - If the ledger froze, it gets unfrozen by sending a new request. If the request has a UI, the UI gets displayed,\n//   otherwise the Nimiq app gets displayed. If the user confirms the new request, the app afterwards behaves normal.\n//   If he declines the request though, any request afterwards seems to time out and the nimiq ledger app needs to be\n//   restarted. This is a corner case that is not covered in this api.\n//\n// Notes about old Firefox versions:\n// - Old Firefox implementation of U2F (when enabled in about:config) did not seem to be compatible with ledger and\n//   threw \"U2F DEVICE_INELIGIBLE\". Previously, we translated that error into the \"not supported\" error, but the current\n//   api doesn't do so anymore as the current Firefox version is compatible and DEVICE_INELIGIBLE gets now thrown\n//   on timeouts (see above).\n\n\n// The following flows should be tested if changing this code:\n// - ledger not connected yet\n// - ledger connected\n// - ledger was connected but relocked\n// - ledger connected but in another app\n// - ledger connected but with old app version\n// - connect timed out\n// - request timed out\n// - user approved action on Ledger\n// - user denied action on Ledger\n// - user cancel in UI\n// - user cancel and immediately make another request\n// - ledger already handling another request (from another tab)\n\n// tslint:disable-next-line:max-line-length\n// TODO: move to own repository:\n// - change implementation to be flow typed and integrate with ledger provided flow libraries directly.\n// - use an appropriate ledger transport library (u2f, WebAuthn, WebUSB, WebBluetooth) depending on platform\n// - Also, the verification and address computation in ledgerjs should be done by Nimiq's crypto methods instead of\n//   unnecessarily bundling tweetnacl and blakejs.\n\nimport LowLevelApi from '../low-level-api/low-level-api';\nimport Observable, { EventListener } from '../lib/observable';\nimport { loadNimiqCore, loadNimiqCryptography } from '../lib/load-nimiq';\nimport { autoDetectTransportTypeToUse, createTransport, isSupported, TransportType } from './transport-utils';\nimport LedgerApiRequest, { RequestParams, RequestType } from './ledger-api-request';\n\ntype Nimiq = typeof import('@nimiq/core-web');\ntype Address = import('@nimiq/core-web').Address;\ntype AccountType = import('@nimiq/core-web').Account.Type;\ntype Transaction = import('@nimiq/core-web').Transaction;\ntype PublicKey = import('@nimiq/core-web').PublicKey;\n\nexport { RequestType, RequestParams };\nexport { isSupported, TransportType };\n\n// events appear at a single point of time while states reflect the current state of the api for a timespan ranging\n// into the future. E.g. if a request was cancelled, a REQUEST_CANCELLED event gets thrown and the state changes to\n// IDLE. Errors trigger an error state (e.g. when app outdated) and thus are a state, not an event.\nexport enum EventType {\n    STATE_CHANGE = 'state-change',\n    REQUEST_SUCCESSFUL = 'request-successful',\n    REQUEST_CANCELLED = 'request-cancelled',\n    CONNECTED = 'connected',\n}\n\nexport enum StateType {\n    IDLE = 'idle',\n    LOADING = 'loading',\n    CONNECTING = 'connecting',\n    REQUEST_PROCESSING = 'request-processing',\n    REQUEST_CANCELLING = 'request-cancelling',\n    ERROR = 'error',\n}\n\nexport enum ErrorType {\n    LEDGER_BUSY = 'ledger-busy',\n    LOADING_DEPENDENCIES_FAILED = 'loading-dependencies-failed',\n    USER_INTERACTION_REQUIRED = 'user-interaction-required',\n    CONNECTION_ABORTED = 'connection-aborted',\n    NO_BROWSER_SUPPORT = 'no-browser-support',\n    APP_OUTDATED = 'app-outdated',\n    WRONG_LEDGER = 'wrong-ledger',\n    REQUEST_ASSERTION_FAILED = 'request-specific-error',\n}\n\nexport interface State {\n    type: StateType;\n    error?: {\n        type: ErrorType,\n        message: string,\n    };\n    request?: LedgerApiRequest<any>;\n}\n\nexport interface TransactionInfo {\n    sender: Address;\n    senderType?: AccountType;\n    recipient: Address;\n    recipientType?: AccountType;\n    value: number; // In Luna\n    fee?: number;\n    validityStartHeight: number;\n    network?: 'main' | 'test' | 'dev';\n    flags?: number;\n    extraData?: Uint8Array;\n}\n\nexport default class LedgerApi {\n    // public fields and methods\n    public static readonly BIP32_BASE_PATH = '44\\'/242\\'/0\\'/';\n    public static readonly BIP32_PATH_REGEX = new RegExp(`^${LedgerApi.BIP32_BASE_PATH}(\\\\d+)'$`);\n    public static readonly MIN_REQUIRED_APP_VERSION = [1, 4, 1];\n    public static readonly WAIT_TIME_AFTER_TIMEOUT = 1500;\n    public static readonly WAIT_TIME_AFTER_ERROR = 500;\n\n    public static get currentState(): State {\n        return LedgerApi._currentState;\n    }\n\n    public static get currentRequest(): LedgerApiRequest<any> | null {\n        return LedgerApi._currentRequest;\n    }\n\n    public static get isBusy(): boolean {\n        return !!LedgerApi._currentRequest;\n    }\n\n    public static get transportType(): TransportType | null {\n        return LedgerApi._transportType;\n    }\n\n    /**\n     * Check for general support or support of a specific transport type. Note that isSupported is additionally exported\n     * as separate export that doesn't require bundling the whole api.\n     * @param [transportType] - Transport type for which to test for support. If omitted test for support of any type.\n     */\n    public static isSupported(transportType?: TransportType): boolean {\n        return isSupported(transportType);\n    }\n\n    /**\n     * Set a specific transport type. Note that an already connected ongoing request will still use the previous\n     * transport type.\n     * @param transportType - Transport type to use for connections to Ledger devices.\n     */\n    public static setTransportType(transportType: TransportType) {\n        if (!isSupported(transportType)) throw new Error('Unsupported transport type.');\n        if (transportType === LedgerApi._transportType) return;\n        LedgerApi._transportType = transportType;\n        // Close api for current transport to create a new one for specified transport type on next request.\n        LedgerApi.disconnect(/* cancelRequest */ false);\n    }\n\n    public static resetTransportType() {\n        const transportType = autoDetectTransportTypeToUse();\n        if (!transportType) return;\n        LedgerApi.setTransportType(transportType);\n    }\n\n    /**\n     * Manually connect to a Ledger. Typically, this is not required as all requests establish a connection themselves.\n     * However, if that connection fails due to a required user interaction / user gesture, you can manually connect in\n     * the context of a user interaction, for example a click.\n     */\n    public static async connect(): Promise<boolean> {\n        LedgerApi._connectionAborted = false; // reset aborted flag on manual connection\n        try {\n            // Initialize the api again if it failed previously, for example due to missing user interaction.\n            await LedgerApi._initializeLowLevelApi();\n        } catch (e) {\n            // Silently continue on errors, same as the other API methods. Error was reported by _initializeLowLevelApi\n            // as error state instead. Only if user aborted the connection or browser is not supported, don't continue.\n            if (/connection aborted|not supported/i.test(e.message || e)) return false;\n        }\n        try {\n            // Use getWalletId to detect when the ledger is connected.\n            await LedgerApi.getWalletId();\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n\n    /**\n     * Disconnect the api and clean up.\n     * @param cancelRequest - Whether to cancel an ongoing request.\n     * @param requestTypeToDisconnect - If specified, only disconnect if no request is going on or if the ongoing\n     *  request is of the specified type.\n     */\n    public static async disconnect(cancelRequest = true, requestTypeToDisconnect?: RequestType) {\n        const { currentRequest } = LedgerApi;\n        if (currentRequest) {\n            if (requestTypeToDisconnect !== undefined && currentRequest.type !== requestTypeToDisconnect) return;\n            if (cancelRequest) {\n                currentRequest.cancel();\n            }\n        }\n\n        const apiPromise = LedgerApi._lowLevelApiPromise;\n        LedgerApi._lowLevelApiPromise = null;\n        LedgerApi._currentlyConnectedWalletId = null;\n\n        if (!apiPromise) return;\n        try {\n            const api = await apiPromise;\n            await api.close();\n        } catch (e) {\n            // Ignore.\n        }\n    }\n\n    /**\n     * Get the 32 byte walletId of the currently connected ledger as base64.\n     * If no ledger is connected, it waits for one to be connected.\n     * Throws, if the request is cancelled.\n     *\n     * If currently a request to the ledger is in process, this call does not require an additional\n     * request to the Ledger. Thus, if you want to know the walletId in conjunction with another\n     * request, try to call this method after initiating the other request but before it finishes.\n     */\n    public static async getWalletId(): Promise<string> {\n        if (LedgerApi._currentlyConnectedWalletId) return LedgerApi._currentlyConnectedWalletId;\n        // we have to wait for connection of ongoing request or initiate a call ourselves\n        if (LedgerApi.isBusy) {\n            // already a request going on. Just wait for it to connect.\n            return new Promise<string>((resolve, reject) => {\n                const onConnect = (walletId: string) => {\n                    LedgerApi.off(EventType.CONNECTED, onConnect);\n                    LedgerApi.off(EventType.REQUEST_CANCELLED, onCancel);\n                    resolve(walletId);\n                };\n                const onCancel = () => {\n                    LedgerApi.off(EventType.CONNECTED, onConnect);\n                    LedgerApi.off(EventType.REQUEST_CANCELLED, onCancel);\n                    reject(new Error('Request cancelled'));\n                };\n                LedgerApi.on(EventType.CONNECTED, onConnect);\n                LedgerApi.on(EventType.REQUEST_CANCELLED, onCancel);\n            });\n        }\n        // We have to send a request ourselves\n        const request = new LedgerApiRequest(\n            RequestType.GET_WALLET_ID,\n            // we're connected when the request get's executed\n            (): Promise<string> => Promise.resolve(LedgerApi._currentlyConnectedWalletId!),\n            {},\n        );\n        return LedgerApi._callLedger(request);\n    }\n\n    public static on(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.on(eventType, listener);\n    }\n\n    public static off(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.off(eventType, listener);\n    }\n\n    public static once(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.once(eventType, listener);\n    }\n\n    public static getBip32PathForKeyId(keyId: number): string {\n        return `${LedgerApi.BIP32_BASE_PATH}${keyId}'`;\n    }\n\n    public static getKeyIdForBip32Path(path: string): number | null {\n        const pathMatch = LedgerApi.BIP32_PATH_REGEX.exec(path);\n        if (!pathMatch) return null;\n        return parseInt(pathMatch[pathMatch.length - 1], 10);\n    }\n\n    public static async deriveAddresses(pathsToDerive: Iterable<string>, walletId?: string)\n        : Promise<Array<{ address: string, keyPath: string }>> {\n        const request = new LedgerApiRequest(RequestType.DERIVE_ADDRESSES,\n            async (api, params): Promise<Array<{ address: string, keyPath: string }>> => {\n                const addressRecords = [];\n                for (const keyPath of params.pathsToDerive!) {\n                    if (request.cancelled) return addressRecords;\n                    // eslint-disable-next-line no-await-in-loop\n                    const { address } = await api.getAddress(\n                        keyPath,\n                        true, // validate\n                        false, // display\n                    );\n                    addressRecords.push({ address, keyPath });\n                }\n                return addressRecords;\n            },\n            {\n                walletId,\n                pathsToDerive,\n            },\n        );\n        // check paths outside of request to avoid endless loop in _callLedger if we'd throw for an invalid keyPath\n        for (const keyPath of pathsToDerive) {\n            if (LedgerApi.BIP32_PATH_REGEX.test(keyPath)) continue;\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    public static async getPublicKey(keyPath: string, walletId?: string): Promise<PublicKey> {\n        const request = new LedgerApiRequest(RequestType.GET_PUBLIC_KEY,\n            async (api, params): Promise<PublicKey> => {\n                const { publicKey } = await api.getPublicKey(\n                    params.keyPath!,\n                    true, // validate\n                    false, // display\n                );\n\n                // Note that the actual load of the Nimiq core and cryptography is triggered in _connect, including\n                // error handling. The call here is just used to get the reference to the Nimiq object and can not fail.\n                const Nimiq = await this._loadNimiq();\n\n                return new Nimiq.PublicKey(publicKey);\n            },\n            {\n                walletId,\n                keyPath,\n            },\n        );\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    public static async getAddress(keyPath: string, walletId?: string): Promise<string> {\n        const request = new LedgerApiRequest(RequestType.GET_ADDRESS,\n            async (api, params): Promise<string> => {\n                const { address } = await api.getAddress(\n                    params.keyPath!,\n                    true, // validate\n                    false, // display\n                );\n                return address;\n            },\n            {\n                walletId,\n                keyPath,\n            },\n        );\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    public static async confirmAddress(userFriendlyAddress: string, keyPath: string, walletId?: string)\n        : Promise<string> {\n        const request = new LedgerApiRequest(RequestType.CONFIRM_ADDRESS,\n            async (api, params): Promise<string> => {\n                const { address: confirmedAddress } = await api.getAddress(\n                    params.keyPath!,\n                    true, // validate\n                    true, // display\n                );\n\n                if (params.addressToConfirm!.replace(/ /g, '').toUpperCase()\n                    !== confirmedAddress.replace(/ /g, '').toUpperCase()) {\n                    LedgerApi._throwError(ErrorType.REQUEST_ASSERTION_FAILED, 'Address mismatch', request);\n                }\n\n                return confirmedAddress;\n            },\n            {\n                walletId,\n                keyPath,\n                addressToConfirm: userFriendlyAddress,\n            },\n        );\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    public static async getConfirmedAddress(keyPath: string, walletId?: string): Promise<string> {\n        const address = await LedgerApi.getAddress(keyPath, walletId);\n        return this.confirmAddress(address, keyPath, walletId);\n    }\n\n    public static async signTransaction(transaction: TransactionInfo, keyPath: string, walletId?: string)\n        : Promise<Transaction> {\n        const request = new LedgerApiRequest(RequestType.SIGN_TRANSACTION,\n            async (api, params): Promise<Transaction> => {\n                // Note: We make api calls outside of try...catch blocks to let the exceptions fall through such that\n                // _callLedger can decide how to behave depending on the api error. All other errors are converted to\n                // REQUEST_ASSERTION_FAILED errors which stop the execution of the request.\n                const { publicKey: signerPubKeyBytes } = await api.getPublicKey(\n                    params.keyPath!,\n                    true, // validate\n                    false, // display\n                );\n\n                // Note that the actual load of the Nimiq core and cryptography is triggered in _connect, including\n                // error handling. The call here is just used to get the reference to the Nimiq object and can not fail.\n                const Nimiq = await this._loadNimiq();\n\n                let nimiqTx: Transaction;\n                let signerPubKey: PublicKey;\n                try {\n                    const tx = params.transaction!;\n                    signerPubKey = new Nimiq.PublicKey(signerPubKeyBytes);\n\n                    const senderType = tx.senderType !== undefined && tx.senderType !== null\n                        ? tx.senderType\n                        : Nimiq.Account.Type.BASIC;\n\n                    const recipientType = tx.recipientType !== undefined && tx.recipientType !== null\n                        ? tx.recipientType\n                        : Nimiq.Account.Type.BASIC;\n\n                    let { network } = tx;\n                    if (!network) {\n                        try {\n                            network = Nimiq.GenesisConfig.NETWORK_NAME as 'main' | 'test' | 'dev';\n                        } catch (e) {\n                            // Genesis config not initialized\n                            network = 'main';\n                        }\n                    }\n\n                    const genesisConfig = Nimiq.GenesisConfig.CONFIGS[network];\n                    const networkId = genesisConfig.NETWORK_ID;\n\n                    const flags = tx.flags !== undefined && tx.flags !== null\n                        ? tx.flags\n                        : Nimiq.Transaction.Flag.NONE;\n                    const fee = tx.fee || 0;\n\n                    if ((tx.extraData && tx.extraData.length !== 0)\n                        || senderType !== Nimiq.Account.Type.BASIC\n                        || recipientType !== Nimiq.Account.Type.BASIC\n                        || flags !== Nimiq.Transaction.Flag.NONE\n                    ) {\n                        const extraData = tx.extraData ? tx.extraData : new Uint8Array(0);\n                        nimiqTx = new Nimiq.ExtendedTransaction(tx.sender, senderType, tx.recipient,\n                            recipientType, tx.value, fee, tx.validityStartHeight, flags, extraData,\n                            /* proof */ undefined, networkId);\n                    } else {\n                        nimiqTx = new Nimiq.BasicTransaction(signerPubKey, tx.recipient, tx.value,\n                            fee, tx.validityStartHeight, /* signature */ undefined, networkId);\n                    }\n                } catch (e) {\n                    this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, e, request);\n                }\n\n                const { signature: signatureBytes } = await api.signTransaction(\n                    params.keyPath!,\n                    nimiqTx!.serializeContent(),\n                );\n\n                try {\n                    const signature = new Nimiq.Signature(signatureBytes);\n\n                    if (nimiqTx! instanceof Nimiq.BasicTransaction) {\n                        nimiqTx.signature = signature;\n                    } else {\n                        nimiqTx!.proof = Nimiq.SignatureProof.singleSig(signerPubKey!, signature).serialize();\n                    }\n                } catch (e) {\n                    this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, e, request);\n                }\n\n                return nimiqTx!;\n            },\n            {\n                walletId,\n                keyPath,\n                transaction,\n            },\n        );\n\n        if (!LedgerApi.BIP32_PATH_REGEX.test(keyPath)) {\n            this._throwError(ErrorType.REQUEST_ASSERTION_FAILED, `Invalid keyPath ${keyPath}`, request);\n        }\n        return LedgerApi._callLedger(request);\n    }\n\n    // private fields and methods\n    private static _transportType: TransportType | null = autoDetectTransportTypeToUse();\n    private static _lowLevelApiPromise: Promise<LowLevelApi> | null = null;\n    private static _currentState: State = { type: StateType.IDLE };\n    private static _currentRequest: LedgerApiRequest<any> | null = null;\n    private static _currentlyConnectedWalletId: string | null = null;\n    private static _connectionAborted: boolean = false;\n    private static _observable = new Observable();\n\n    private static async _callLedger<T>(request: LedgerApiRequest<T>): Promise<T> {\n        if (LedgerApi.isBusy) {\n            LedgerApi._throwError(ErrorType.LEDGER_BUSY, 'Only one call to Ledger at a time allowed',\n                request);\n        }\n        LedgerApi._connectionAborted = false; // user is initiating a new request\n        try {\n            LedgerApi._currentRequest = request;\n            /* eslint-disable no-await-in-loop, no-async-promise-executor */\n            return await new Promise<T>(async (resolve, reject) => {\n                let canCancelDirectly = false;\n                request.on(LedgerApiRequest.EVENT_CANCEL, () => {\n                    // If we can, reject the call right away. Otherwise just notify that the request was requested to be\n                    // cancelled such that the user can cancel the call on the ledger.\n                    LedgerApi._setState(StateType.REQUEST_CANCELLING);\n                    if (canCancelDirectly) {\n                        LedgerApi._fire(EventType.REQUEST_CANCELLED, request);\n                        reject(new Error('Request cancelled'));\n                    }\n                });\n                while (!request.cancelled) {\n                    try {\n                        const api = await LedgerApi._connect(request.params.walletId);\n                        if (request.cancelled) break;\n                        if (!request.cancelled) {\n                            LedgerApi._setState(StateType.REQUEST_PROCESSING);\n                        }\n                        canCancelDirectly = false; // sending request which has to be resolved / cancelled by the Ledger\n                        const result = await request.call(api);\n                        if (request.cancelled) break;\n                        LedgerApi._fire(EventType.REQUEST_SUCCESSFUL, request, result);\n                        resolve(result);\n                        return;\n                    } catch (e) {\n                        console.log(e);\n                        const message = (e.message || e || '').toLowerCase();\n                        const isTimeout = /timeout|u2f device_ineligible|u2f other_error/i.test(message);\n                        const isLocked = /locked|0x6804/i.test(message);\n                        const isConnectedToDashboard = /incorrect length/i.test(message);\n                        if (LedgerApi._transportType === TransportType.U2F || isLocked) {\n                            // For u2f we don't get notified about disconnects therefore clear connection on every\n                            // exception. When locked clear connection for all transport types as user might unlock with\n                            // a different PIN for another wallet.\n                            LedgerApi._currentlyConnectedWalletId = null;\n                        }\n                        if (isTimeout || isConnectedToDashboard) canCancelDirectly = true;\n                        // Test whether user cancelled call on ledger\n                        if (message.indexOf('denied') !== -1 // user rejected confirmAddress\n                            || message.indexOf('rejected') !== -1) { // user rejected signTransaction\n                            break; // continue after loop\n                        }\n                        // Errors that should end the request\n                        if ((LedgerApi.currentState.error\n                            && LedgerApi.currentState.error.type === ErrorType.REQUEST_ASSERTION_FAILED)\n                            || message.indexOf('not supported') !== -1) { // no browser support\n                            reject(e);\n                            return;\n                        }\n                        // On other errors try again\n                        if (!/busy|outdated|connection aborted|user gesture|dependencies|wrong ledger/i.test(message)\n                            && !isTimeout && !isLocked && !isConnectedToDashboard) {\n                            console.warn('Unknown Ledger Error', e);\n                        }\n                        // Wait a little when replacing a previous request (see notes at top).\n                        const waitTime = isTimeout ? LedgerApi.WAIT_TIME_AFTER_TIMEOUT\n                            // If the API tells us that the ledger is busy (see notes at top) use a longer wait time to\n                            // reduce the chance that we hit unfortunate 1.5s window after timeout of cancelled call\n                            : message.indexOf('busy') !== -1 ? 4 * LedgerApi.WAIT_TIME_AFTER_TIMEOUT\n                                // For other exceptions wait a little to avoid busy endless loop for some exceptions.\n                                : LedgerApi.WAIT_TIME_AFTER_ERROR;\n                        await new Promise((resolve2) => setTimeout(resolve2, waitTime));\n                    }\n                }\n                LedgerApi._fire(EventType.REQUEST_CANCELLED, request);\n                reject(new Error('Request cancelled'));\n            });\n            /* eslint-enable no-await-in-loop, no-async-promise-executor */\n        } finally {\n            LedgerApi._currentRequest = null;\n            if (LedgerApi._transportType === TransportType.U2F) {\n                LedgerApi._currentlyConnectedWalletId = null; // reset as we don't note when Ledger gets disconnected\n            }\n            const errorType = LedgerApi.currentState.error ? LedgerApi.currentState.error.type : null;\n            if (errorType !== ErrorType.NO_BROWSER_SUPPORT\n                && errorType !== ErrorType.REQUEST_ASSERTION_FAILED) {\n                LedgerApi._setState(StateType.IDLE);\n            }\n        }\n    }\n\n    private static async _connect(walletId?: string): Promise<LowLevelApi> {\n        // Resolves when connected to unlocked ledger with open Nimiq app otherwise throws an exception after timeout,\n        // in contrast to the public connect method which uses getWalletId to listen for a connection or to try to\n        // connect repeatedly until success via _callLedger which uses the private _connect under the hood. Also this\n        // method is not publicly exposed to avoid that it could be invoked multiple times in parallel which the ledger\n        // requests called here do not allow. Additionally, this method exposes the low level api which is private.\n        // If the Ledger is already connected and the library already loaded, the call typically takes < 500ms.\n        if (LedgerApi._connectionAborted) {\n            // When the connection was aborted, don't retry connecting until a manual connection is requested.\n            throw new Error('Connection aborted');\n        }\n        try {\n            const nimiqPromise = this._loadNimiq();\n            const api = await LedgerApi._initializeLowLevelApi();\n            if (!LedgerApi._currentlyConnectedWalletId) {\n                // Not connected yet.\n                LedgerApi._setState(StateType.CONNECTING);\n                // To check whether the connection to Nimiq app is established and to calculate the walletId. Set\n                // validate to false as otherwise the call is much slower. For U2F this can also unfreeze the ledger\n                // app, see notes at top. Using getPublicKey and not getAppConfiguration, as other apps also respond to\n                // getAppConfiguration (for example the Ethereum app).\n                const { publicKey: firstAddressPubKeyBytes } = await api.getPublicKey(\n                    LedgerApi.getBip32PathForKeyId(0),\n                    false, // validate\n                    false, // display\n                );\n                const { version } = await api.getAppConfiguration();\n                if (!LedgerApi._isAppVersionSupported(version)) throw new Error('Ledger Nimiq App is outdated.');\n\n                try {\n                    const Nimiq = await nimiqPromise;\n                    // Use sha256 as blake2b yields the nimiq address\n                    LedgerApi._currentlyConnectedWalletId = Nimiq.Hash.sha256(firstAddressPubKeyBytes).toBase64();\n                } catch (e) {\n                    LedgerApi._throwError(ErrorType.LOADING_DEPENDENCIES_FAILED,\n                        `Failed loading dependencies: ${e.message || e}`);\n                }\n            }\n            if (walletId !== undefined && LedgerApi._currentlyConnectedWalletId !== walletId) {\n                throw new Error('Wrong Ledger connected');\n            }\n            this._fire(EventType.CONNECTED, LedgerApi._currentlyConnectedWalletId);\n            return api;\n        } catch (e) {\n            const message = (e.message || e || '').toLowerCase();\n            if (message.indexOf('wrong ledger') !== -1) {\n                LedgerApi._throwError(ErrorType.WRONG_LEDGER, e);\n            }\n            LedgerApi._currentlyConnectedWalletId = null;\n            if (message.indexOf('outdated') !== -1) {\n                LedgerApi._throwError(ErrorType.APP_OUTDATED, e);\n            } else if (message.indexOf('busy') !== -1) {\n                LedgerApi._throwError(ErrorType.LEDGER_BUSY, e);\n            }\n            // Just rethrow the error and not fire an error state for _initializeDependencies errors which fires error\n            // states itself and for other errors (like timeout, dongle locked) that just keep the API retrying.\n            throw e;\n        }\n    }\n\n    private static async _initializeLowLevelApi(): Promise<LowLevelApi> {\n        const transportType = LedgerApi._transportType;\n        LedgerApi._lowLevelApiPromise = LedgerApi._lowLevelApiPromise\n            || (async () => {\n                LedgerApi._setState(StateType.LOADING);\n                if (!transportType) throw new Error('No browser support');\n                const transport = await createTransport(transportType);\n                const onDisconnect = () => {\n                    console.log('Ledger disconnected');\n                    transport.off('disconnect', onDisconnect);\n                    if (this._transportType !== transportType) return;\n                    // A disconnected transport can not be reconnected. Therefore reset the _lowLevelApiPromise.\n                    LedgerApi._lowLevelApiPromise = null;\n                    LedgerApi._currentlyConnectedWalletId = null;\n                };\n                transport.on('disconnect', onDisconnect);\n                return new LowLevelApi(transport);\n            })();\n        try {\n            const api = await LedgerApi._lowLevelApiPromise;\n            if (this._transportType === transportType) return api;\n            // Transport type changed while we were connecting; rerun.\n            return LedgerApi._initializeLowLevelApi();\n        } catch (e) {\n            if (this._transportType === transportType) {\n                LedgerApi._lowLevelApiPromise = null;\n                const message = (e.message || e).toLowerCase();\n                if (message.indexOf('no device selected') !== -1) {\n                    LedgerApi._connectionAborted = true;\n                    LedgerApi._throwError(ErrorType.CONNECTION_ABORTED, `Connection aborted: ${message}`);\n                } else if (message.indexOf('user gesture') !== -1) {\n                    LedgerApi._throwError(ErrorType.USER_INTERACTION_REQUIRED, e);\n                } else if (message.indexOf('browser support') !== -1) {\n                    LedgerApi._throwError(ErrorType.NO_BROWSER_SUPPORT,\n                        'Ledger not supported by browser or support not enabled.');\n                } else {\n                    LedgerApi._throwError(ErrorType.LOADING_DEPENDENCIES_FAILED,\n                        `Failed loading dependencies: ${message}`);\n                }\n            }\n            // Transport type changed while we were connecting; ignore error and rerun\n            return LedgerApi._initializeLowLevelApi();\n        }\n    }\n\n    private static async _loadNimiq(): Promise<Nimiq> {\n        // Small helper that throws a \"Failed loading dependencies\" exception on error. Note that we don't need to cache\n        // a promise here as in _initializeLowLevelApi as loadNimiqCore and loadNimiqCryptography already do that.\n        try {\n            const [Nimiq] = await Promise.all([\n                loadNimiqCore(),\n                // needed for walletId hashing and pub key to address derivation in SignatureProof and BasicTransaction\n                loadNimiqCryptography(),\n            ]);\n            return Nimiq;\n        } catch (e) {\n            throw new Error(`Failed loading dependencies: ${e.message || e}`);\n        }\n    }\n\n    private static _isAppVersionSupported(versionString: string): boolean {\n        const version = versionString.split('.').map((part) => parseInt(part, 10));\n        for (let i = 0; i < LedgerApi.MIN_REQUIRED_APP_VERSION.length; ++i) {\n            if (typeof version[i] === 'undefined' || version[i] < LedgerApi.MIN_REQUIRED_APP_VERSION[i]) return false;\n            if (version[i] > LedgerApi.MIN_REQUIRED_APP_VERSION[i]) return true;\n        }\n        return true;\n    }\n\n    private static _setState(state: State | StateType): void {\n        if (typeof state === 'string') {\n            // it's an entry from LedgerApi.StateType enum\n            state = { type: state };\n        }\n        state.request = !state.request && LedgerApi._currentRequest ? LedgerApi._currentRequest : state.request;\n\n        if (LedgerApi._currentState.type === state.type\n            && (LedgerApi._currentState.error === state.error\n                || (!!LedgerApi._currentState.error && !!state.error\n                    && LedgerApi._currentState.error.type === state.error.type))\n            && LedgerApi._currentState.request === state.request) return;\n        LedgerApi._currentState = state;\n        LedgerApi._fire(EventType.STATE_CHANGE, state);\n    }\n\n    private static _throwError(\n        type: ErrorType,\n        error: Error | string,\n        request?: LedgerApiRequest<any>,\n    ): void {\n        const state: State = {\n            type: StateType.ERROR,\n            error: {\n                type,\n                message: typeof error === 'string' ? error : error.message,\n            },\n        };\n        if (request) state.request = request;\n        LedgerApi._setState(state);\n        if (typeof error === 'string') {\n            throw new Error(error);\n        } else {\n            throw error;\n        }\n    }\n\n    private static _fire(eventName: EventType, ...args: any[]): void {\n        LedgerApi._observable.fire(eventName, ...args);\n    }\n}\n"],"names":[],"mappings":"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"}