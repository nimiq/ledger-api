{"version":3,"file":"ledger-api.es.js","sources":["source-mapped://source-mapped/src/lib/observable.ts","source-mapped://source-mapped/src/high-level-api/transport-utils.ts","source-mapped://source-mapped/src/high-level-api/constants.ts","source-mapped://source-mapped/src/high-level-api/bip32-utils.ts","source-mapped://source-mapped/src/high-level-api/error-state.ts","source-mapped://source-mapped/src/high-level-api/ledger-api.ts"],"sourcesContent":["export type EventListener = (...args: any[]) => void;\n\nexport default class Observable {\n    private _listeners: Map<string, EventListener[]> = new Map();\n\n    public on(eventType: string, listener: EventListener): void {\n        if (!this._listeners.has(eventType)) {\n            this._listeners.set(eventType, [listener]);\n        } else {\n            this._listeners.get(eventType)!.push(listener);\n        }\n    }\n\n    public off(eventType: string, listener: EventListener): void {\n        const listenersForEvent = this._listeners.get(eventType);\n        if (!listenersForEvent) return;\n        const index = listenersForEvent.indexOf(listener);\n        if (index === -1) return;\n        listenersForEvent.splice(index, 1);\n    }\n\n    public once(eventType: string, listener: EventListener): void {\n        const onceListener: EventListener = ((...args: any[]) => {\n            this.off(eventType, onceListener);\n            listener(...args);\n        });\n        this.on(eventType, onceListener);\n    }\n\n    public fire(eventName: string, ...args: any[]): void {\n        // Let current micro task finish before invoking listeners\n        setTimeout(() => {\n            const listenersForEvent = this._listeners.get(eventName);\n            if (!listenersForEvent) return;\n            for (const listener of listenersForEvent) {\n                listener(...args);\n            }\n        }, 0);\n    }\n}\n","type TransportConstructor = typeof import('@ledgerhq/hw-transport').default;\ntype TransportWebUsbConstructor = typeof import('@ledgerhq/hw-transport-webusb').default;\n\nexport enum TransportType {\n    WEB_HID = 'web-hid',\n    WEB_USB = 'web-usb',\n    WEB_BLE = 'web-ble',\n    WEB_AUTHN = 'web-authn',\n    U2F = 'u2f',\n}\n\nexport function isSupported(transportType?: TransportType): boolean {\n    if (window.location.protocol !== 'https:') return false;\n    if (!transportType) return !!autoDetectTransportTypeToUse();\n    // inspired by @ledgerhq/hw-transport libs\n    switch (transportType) {\n        case TransportType.WEB_HID:\n            return 'hid' in window.navigator;\n        case TransportType.WEB_USB:\n            // @ts-ignore\n            return 'usb' in window.navigator && typeof window.navigator.usb.getDevices === 'function';\n        case TransportType.WEB_BLE:\n            return 'bluetooth' in window.navigator;\n        case TransportType.WEB_AUTHN:\n            return !!navigator.credentials;\n        case TransportType.U2F:\n            // Note that Chrome, Opera and Edge use an internal, hidden cryptotoken extension to handle u2f\n            // (https://github.com/google/u2f-ref-code/blob/master/u2f-gae-demo/war/js/u2f-api.js) which does not\n            // expose the u2f api on window. Support via that extension is not detected by this check. However, as\n            // these browsers support WebUSB, this is acceptable and we don't use a more elaborate check like the one\n            // in the 'u2f-api' package to avoid bundling it and also because it's async, complicating the code.\n            // @ts-ignore\n            return 'u2f' in window && typeof window.u2f.sign === 'function';\n        default:\n            return false;\n    }\n}\n\nexport function autoDetectTransportTypeToUse(): TransportType | null {\n    // Determine the best available transport type. Exclude WebBle as it's only suitable for Nano X.\n    let transportTypesByPreference;\n    // HID has better compatibility on Windows due to driver issues for WebUSB for the Nano X. On other\n    // platforms however, WebUSB is preferable for multiple reasons (see transport-comparison.md).\n    // TODO this situation needs to be re-evaluated once WebHID is stable\n    const isWindows = /Win/.test(window.navigator.platform); // see https://stackoverflow.com/a/38241481\n    if (isWindows) {\n        transportTypesByPreference = [TransportType.WEB_HID, TransportType.WEB_USB];\n    } else {\n        transportTypesByPreference = [TransportType.WEB_USB, TransportType.WEB_HID];\n    }\n    // WebAuthn as preferred fallback, as compared to U2F better browser support and less quirky / not deprecated and\n    // works better with Nano X. But causes a popup in Chrome which U2F does not. In Firefox has same popup as U2F and\n    // in Windows also triggers Window's native security popup (see transport-comparison.md).\n    transportTypesByPreference.push(TransportType.WEB_AUTHN);\n    // U2F as legacy fallback. The others are preferred as U2F can time out and causes native Windows security popups\n    // in Windows and additionally Firefox internal popups in Firefox on all platforms (see transport-comparison.md).\n    transportTypesByPreference.push(TransportType.U2F);\n    return transportTypesByPreference.find(isSupported) || null;\n}\n\n/**\n * Lazy load the library for a transport type.\n * @param transportType\n */\nexport async function loadTransportLibrary(transportType: TransportType)\n    : Promise<TransportWebUsbConstructor|TransportConstructor> {\n    switch (transportType) {\n        case TransportType.WEB_HID:\n            return (await import('@ledgerhq/hw-transport-webhid')).default;\n        case TransportType.WEB_USB:\n            return (await import('@ledgerhq/hw-transport-webusb')).default;\n        case TransportType.WEB_BLE:\n            return (await import('@ledgerhq/hw-transport-web-ble')).default;\n        case TransportType.WEB_AUTHN:\n            return (await import('@ledgerhq/hw-transport-webauthn')).default;\n        case TransportType.U2F:\n            return (await import('@ledgerhq/hw-transport-u2f')).default;\n        default:\n            throw new Error(`Unknown transport type ${transportType}`);\n    }\n}\n","// Constants needed in lazy chunks and the main chunk.\n// As a separate file to be able to use these constants in the main chunk without the need to import the entire lazy\n// chunks and to avoid circular dependencies between main entry and other files.\n\nexport enum Coin {\n    NIMIQ = 'Nimiq',\n    BITCOIN = 'Bitcoin',\n}\n\nexport enum Network {\n    MAINNET = 'main',\n    TESTNET = 'test',\n}\n\nexport enum AddressTypeBitcoin {\n    LEGACY = 'legacy-bitcoin',\n    P2SH_SEGWIT = 'p2sh-segwit-bitcoin',\n    NATIVE_SEGWIT = 'native-segwit-bitcoin',\n}\n\nexport const REQUEST_EVENT_CANCEL = 'cancel';\n\nexport enum RequestTypeNimiq {\n    GET_WALLET_ID = 'get-wallet-id-nimiq',\n    DERIVE_ADDRESSES = 'derive-addresses-nimiq',\n    GET_PUBLIC_KEY = 'get-public-key-nimiq',\n    GET_ADDRESS = 'get-address-nimiq',\n    SIGN_TRANSACTION = 'sign-transaction-nimiq',\n}\n\nexport enum RequestTypeBitcoin {\n    GET_WALLET_ID = 'get-wallet-id-bitcoin',\n    GET_ADDRESS_AND_PUBLIC_KEY = 'get-address-and-public-key-bitcoin',\n    GET_EXTENDED_PUBLIC_KEY = 'get-extended-public-key-bitcoin',\n    SIGN_TRANSACTION = 'sign-transaction-bitcoin',\n}\n","import { AddressTypeBitcoin, Coin, Network } from './constants';\n\ntype Bip32PathParams = {\n    addressIndex: number,\n    accountIndex?: number,\n} & ({\n    coin: Coin.NIMIQ,\n} | {\n    coin: Coin.BITCOIN,\n    addressType?: AddressTypeBitcoin,\n    network?: Network,\n    isInternal?: boolean,\n});\n\n// See BIP44\nconst PATH_REGEX = new RegExp(\n    '^'\n    + '(\\\\d+)\\'' // purpose id; BIP44 (BTC legacy or Nimiq) / BIP49 (BTC nested SegWit) / BIP84 (BTC native SegWit)\n    + '/(\\\\d+)\\'' // coin type; 0 for Bitcoin Mainnet, 1 for Bitcoin Testnet, 242 for Nimiq\n    + '/(\\\\d+)\\'' // account index\n    + '(?:/(\\\\d+))?' // 0 for external or 1 for internal address (change); non-hardened; unset for Nimiq\n    + '/(\\\\d+)(\\'?)' // address index; non-hardened for BTC, hardened for Nimiq\n    + '$',\n);\n\nconst PURPOSE_ID_MAP_BITCOIN = new Map<AddressTypeBitcoin, number>([\n    [AddressTypeBitcoin.LEGACY, 44],\n    [AddressTypeBitcoin.P2SH_SEGWIT, 49],\n    [AddressTypeBitcoin.NATIVE_SEGWIT, 84],\n]);\n\n/**\n * Generate a bip32 path according to path layout specified in bip44 for the specified parameters.\n */\nexport function getBip32Path(params: Bip32PathParams): string {\n    // set defaults\n    params = {\n        accountIndex: 0,\n        ...params,\n    };\n    switch (params.coin) {\n        case Coin.NIMIQ:\n            return `44'/242'/${params.accountIndex}'/${params.addressIndex}'`; // Nimiq paths are fully hardened\n        case Coin.BITCOIN: {\n            // set bitcoin specific defaults\n            params = {\n                addressType: AddressTypeBitcoin.NATIVE_SEGWIT,\n                network: Network.MAINNET,\n                isInternal: false,\n                ...params,\n            };\n            const purposeId = PURPOSE_ID_MAP_BITCOIN.get(params.addressType!);\n            const coinType = params.network === Network.TESTNET ? 1 : 0;\n            const changeType = params.isInternal ? 1 : 0;\n            return `${purposeId}'/${coinType}'/${params.accountIndex}'/${changeType}/${params.addressIndex}`;\n        }\n        default:\n            throw new Error(`Unsupported coin: ${(params as any).coin}`);\n    }\n}\n\n/**\n * Parse bip32 path according to path layout specified in bip44.\n */\nexport function parseBip32Path(path: string): Required<Bip32PathParams> {\n    const pathMatch = path.match(PATH_REGEX);\n    if (!pathMatch) throw new Error(`${path} is not a supported bip32 path.`);\n    const purposeId = parseInt(pathMatch[1], 10);\n    const coinType = parseInt(pathMatch[2], 10);\n    const accountIndex = parseInt(pathMatch[3], 10);\n    const changeType = pathMatch[4];\n    const addressIndex = parseInt(pathMatch[5], 10);\n    const isAddressIndexHardened = !!pathMatch[6];\n\n    // Check indices for validity according to bip32. No need to check for negative or fractional numbers, as these are\n    // not accepted by the regex.\n    if (accountIndex >= 2 ** 31 || addressIndex >= 2 ** 31) throw new Error('Invalid index');\n\n    switch (coinType) {\n        case 242:\n            // Nimiq\n            if (purposeId !== 44) throw new Error('Purpose id must be 44 for Nimiq');\n            if (changeType !== undefined) throw new Error('Specifying a change type is not supported for Nimiq');\n            if (!isAddressIndexHardened) throw new Error('Address index must be hardened for Nimiq');\n            return {\n                coin: Coin.NIMIQ,\n                accountIndex,\n                addressIndex,\n            };\n        case 0:\n        case 1: {\n            // Bitcoin\n            const knownPurposeIds = [...PURPOSE_ID_MAP_BITCOIN.values()];\n            if (!knownPurposeIds.includes(purposeId)) throw new Error('Purpose id must be 44, 49 or 84 for Bitcoin');\n            if (changeType === undefined) throw new Error('Specifying a change type is required for Bitcoin');\n            if (changeType !== '0' && changeType !== '1') throw new Error('Invalid change type for Bitcoin');\n            if (isAddressIndexHardened) throw new Error('Address index must not be hardened for Bitcoin');\n            const addressType = [...PURPOSE_ID_MAP_BITCOIN.entries()].find(([,pId]) => pId === purposeId)![0];\n            const network = coinType === 0 ? Network.MAINNET : Network.TESTNET;\n            const isInternal = changeType === '1';\n            return {\n                coin: Coin.BITCOIN,\n                accountIndex,\n                addressIndex,\n                addressType,\n                network,\n                isInternal,\n            };\n        }\n        default:\n            throw new Error(`Unsupported coin type ${coinType}`);\n    }\n}\n","type StateTypeError = import('./ledger-api').StateType.ERROR;\n\ntype RequestBase = import('./requests/request').default<any>;\ntype SpecificRequest = import('./ledger-api').Request;\n\nexport enum ErrorType {\n    LEDGER_BUSY = 'ledger-busy',\n    LOADING_DEPENDENCIES_FAILED = 'loading-dependencies-failed',\n    USER_INTERACTION_REQUIRED = 'user-interaction-required',\n    CONNECTION_ABORTED = 'connection-aborted',\n    BROWSER_UNSUPPORTED = 'browser-unsupported',\n    APP_OUTDATED = 'app-outdated',\n    WRONG_WALLET = 'wrong-wallet',\n    WRONG_APP = 'wrong-app',\n    REQUEST_ASSERTION_FAILED = 'request-specific-error',\n}\n\nexport default class ErrorState<T extends ErrorType = ErrorType> extends Error {\n    public readonly type: StateTypeError = 'error' as StateTypeError; // state type\n    public readonly errorType: T;\n    // request specified as SpecificRequest instead of RequestBase such that an app using the api knows what request\n    // types to expect here.\n    public request: T extends ErrorType.LOADING_DEPENDENCIES_FAILED ? SpecificRequest | undefined : SpecificRequest;\n\n    constructor(\n        errorType: T,\n        messageOrError: string | Error,\n        // request specified as RequestBase here to allow simple throwing from a SpecificRequest parent class.\n        request: T extends ErrorType.LOADING_DEPENDENCIES_FAILED ? RequestBase | undefined : RequestBase,\n    ) {\n        super(messageOrError.toString());\n\n        if (messageOrError instanceof Error && messageOrError.stack) {\n            this.stack = messageOrError.stack;\n        } else if (Error.captureStackTrace) {\n            // Maintains proper stack trace for where our error was thrown (only available on V8), see\n            // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error#Custom_Error_Types\n            Error.captureStackTrace(this, ErrorState);\n        }\n\n        this.name = 'LedgerErrorState';\n        this.errorType = errorType;\n        this.request = request as any;\n    }\n}\n","import Observable, { EventListener } from '../lib/observable';\nimport { autoDetectTransportTypeToUse, isSupported, loadTransportLibrary, TransportType } from './transport-utils';\nimport { getBip32Path, parseBip32Path } from './bip32-utils';\nimport ErrorState, { ErrorType } from './error-state';\nimport {\n    AddressTypeBitcoin,\n    Coin,\n    Network,\n    REQUEST_EVENT_CANCEL,\n    RequestTypeBitcoin,\n    RequestTypeNimiq,\n} from './constants';\n\ntype TransportConstructor = typeof import('@ledgerhq/hw-transport').default;\ntype TransportWebUsbConstructor = typeof import('@ledgerhq/hw-transport-webusb').default;\ntype Transport = InstanceType<TransportConstructor | TransportWebUsbConstructor>;\n\ntype CoinAppConnection = import('./requests/request').CoinAppConnection;\n\ntype RequestType = RequestTypeNimiq | RequestTypeBitcoin;\n\ntype RequestGetWalletIdNimiqConstructor = typeof import('./requests/nimiq/request-get-wallet-id-nimiq').default;\ntype RequestGetPublicKeyNimiqConstructor = typeof import('./requests/nimiq/request-get-public-key-nimiq').default;\ntype RequestGetAddressNimiqConstructor = typeof import('./requests/nimiq/request-get-address-nimiq').default;\ntype RequestDeriveAddressesNimiqConstructor = typeof import('./requests/nimiq/request-derive-addresses-nimiq').default;\ntype RequestSignTransactionNimiqConstructor = typeof import('./requests/nimiq/request-sign-transaction-nimiq').default;\n\ntype RequestGetWalletIdBitcoinConstructor = typeof import('./requests/bitcoin/request-get-wallet-id-bitcoin').default;\ntype RequestGetAddressAndPublicKeyBitcoinConstructor =\n    typeof import('./requests/bitcoin/request-get-address-and-public-key-bitcoin').default;\ntype RequestGetExtendedPublicKeyBitcoinConstructor =\n    typeof import('./requests/bitcoin/request-get-extended-public-key-bitcoin').default;\ntype RequestSignTransactionBitcoinConstructor =\n    typeof import('./requests/bitcoin/request-sign-transaction-bitcoin').default;\n\n// define Request type as actually defined request classes to be more specific than the abstract parent class\n/* eslint-disable @typescript-eslint/indent */\ntype RequestConstructor = RequestGetWalletIdNimiqConstructor | RequestGetPublicKeyNimiqConstructor\n    | RequestGetAddressNimiqConstructor | RequestDeriveAddressesNimiqConstructor\n    | RequestSignTransactionNimiqConstructor\n    | RequestGetWalletIdBitcoinConstructor | RequestGetAddressAndPublicKeyBitcoinConstructor\n    | RequestGetExtendedPublicKeyBitcoinConstructor | RequestSignTransactionBitcoinConstructor;\n/* eslint-enable @typescript-eslint/indent */\ntype Request = InstanceType<RequestConstructor>;\n\ntype PublicKeyNimiq = import('@nimiq/core-web').PublicKey;\ntype TransactionInfoNimiq = import('./requests/nimiq/request-sign-transaction-nimiq').TransactionInfoNimiq;\ntype TransactionNimiq = import('@nimiq/core-web').Transaction;\n\ntype TransactionInfoBitcoin = import('./requests/bitcoin/request-sign-transaction-bitcoin').TransactionInfoBitcoin;\n\nexport { isSupported, TransportType };\nexport { getBip32Path, parseBip32Path };\nexport { ErrorType, ErrorState };\nexport { Coin, AddressTypeBitcoin, Network };\nexport { CoinAppConnection, RequestTypeNimiq, RequestTypeBitcoin, RequestType, Request };\nexport { TransactionInfoNimiq, TransactionInfoBitcoin };\n\nexport enum StateType {\n    IDLE = 'idle',\n    LOADING = 'loading',\n    CONNECTING = 'connecting',\n    REQUEST_PROCESSING = 'request-processing',\n    REQUEST_CANCELLING = 'request-cancelling',\n    ERROR = 'error',\n}\n\n// events appear at a single point of time while states reflect the current state of the api for a timespan ranging\n// into the future. E.g. if a request was cancelled, a REQUEST_CANCELLED event gets thrown and the state changes to\n// IDLE. Errors trigger an error state (e.g. when app outdated) and thus are a state, not an event.\nexport enum EventType {\n    STATE_CHANGE = 'state-change',\n    REQUEST_SUCCESSFUL = 'request-successful',\n    REQUEST_CANCELLED = 'request-cancelled',\n    CONNECTED = 'connected',\n}\n\nexport type State = {\n    type: StateType.IDLE | StateType.LOADING | StateType.CONNECTING,\n    request?: Request,\n} | {\n    type: StateType.REQUEST_PROCESSING | StateType.REQUEST_CANCELLING,\n    request: Request,\n} | ErrorState;\n\nexport default class LedgerApi {\n    // public fields and methods\n    public static readonly WAIT_TIME_AFTER_TIMEOUT = 1500;\n    public static readonly WAIT_TIME_AFTER_ERROR = 500;\n\n    public static readonly Nimiq = {\n        /**\n         * Get the 32 byte wallet id of the currently connected Nimiq wallet as base64.\n         */\n        async getWalletId(): Promise<string> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestGetWalletIdNimiqConstructor>(\n                import('./requests/nimiq/request-get-wallet-id-nimiq'),\n            ));\n        },\n\n        /**\n         * Get the public key for a given bip32 key path. Optionally expect a specific wallet id.\n         */\n        async getPublicKey(keyPath: string, expectedWalletId?: string): Promise<PublicKeyNimiq> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestGetPublicKeyNimiqConstructor>(\n                import('./requests/nimiq/request-get-public-key-nimiq'),\n                keyPath, expectedWalletId,\n            ));\n        },\n\n        /**\n         * Get the address for a given bip32 key path. Optionally display the address on the Ledger screen for\n         * verification, expect a specific address or expect a specific wallet id.\n         */\n        async getAddress(keyPath: string, display = false, expectedAddress?: string, expectedWalletId?: string)\n            : Promise<string> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestGetAddressNimiqConstructor>(\n                import('./requests/nimiq/request-get-address-nimiq'),\n                keyPath, display, expectedAddress, expectedWalletId,\n            ));\n        },\n\n        /**\n         * Utility function that directly gets a confirmed address.\n         */\n        async getConfirmedAddress(keyPath: string, expectedWalletId?: string): Promise<string> {\n            const address = await LedgerApi.Nimiq.getAddress(keyPath, false, undefined, expectedWalletId);\n            return LedgerApi.Nimiq.getAddress(keyPath, true, address, expectedWalletId);\n        },\n\n        /**\n         * Derive addresses for given bip32 key paths. Optionally expect a specific wallet id.\n         */\n        async deriveAddresses(pathsToDerive: Iterable<string>, expectedWalletId?: string)\n            : Promise<Array<{ address: string, keyPath: string }>> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestDeriveAddressesNimiqConstructor>(\n                import('./requests/nimiq/request-derive-addresses-nimiq'),\n                pathsToDerive, expectedWalletId,\n            ));\n        },\n\n        /**\n         * Sign a transaction for a signing key specified by its bip32 key path. Note that the signing key /\n         * corresponding address does not necessarily need to be the transaction's sender address for example for\n         * transactions sent from vesting contracts. Optionally expect a specific wallet id.\n         */\n        async signTransaction(transaction: TransactionInfoNimiq, keyPath: string, expectedWalletId?: string)\n            : Promise<TransactionNimiq> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestSignTransactionNimiqConstructor>(\n                import('./requests/nimiq/request-sign-transaction-nimiq'),\n                keyPath, transaction, expectedWalletId,\n            ));\n        },\n    };\n\n    public static readonly Bitcoin = {\n        /**\n         * Get the 32 byte wallet id of the currently connected Bitcoin wallet / app for a specific network as base64.\n         */\n        async getWalletId(network: Network): Promise<string> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestGetWalletIdBitcoinConstructor>(\n                import('./requests/bitcoin/request-get-wallet-id-bitcoin'),\n                network,\n            ));\n        },\n\n        /**\n         * Get the public key, address and bip32 chain code for a given bip32 key path. Optionally display the address\n         * on the Ledger screen for verification, expect a specific address or expect a specific wallet id.\n         */\n        async getAddressAndPublicKey(\n            keyPath: string,\n            display = false,\n            expectedAddress?: string,\n            expectedWalletId?: string,\n        ): Promise<{ publicKey: string, address: string, chainCode: string }> {\n            return LedgerApi._callLedger(\n                await LedgerApi._createRequest<RequestGetAddressAndPublicKeyBitcoinConstructor>(\n                    import('./requests/bitcoin/request-get-address-and-public-key-bitcoin'),\n                    keyPath, display, expectedAddress, expectedWalletId,\n                ),\n            );\n        },\n\n        /**\n         * Utility function that directly gets a confirmed address.\n         */\n        async getConfirmedAddressAndPublicKey(keyPath: string, expectedWalletId?: string)\n            : Promise<{ publicKey: string, address: string, chainCode: string }> {\n            const { address } = await LedgerApi.Bitcoin.getAddressAndPublicKey(\n                keyPath,\n                false,\n                undefined,\n                expectedWalletId,\n            );\n            return LedgerApi.Bitcoin.getAddressAndPublicKey(keyPath, true, address, expectedWalletId);\n        },\n\n        /**\n         * Get the extended public key for a bip32 path from which addresses can be derived, encoded as specified in\n         * bip32. The key path must follow the bip44 specification and at least be defined to the account level.\n         * Optionally expect a specific wallet id.\n         */\n        async getExtendedPublicKey(keyPath: string, expectedWalletId?: string): Promise<string> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestGetExtendedPublicKeyBitcoinConstructor>(\n                import('./requests/bitcoin/request-get-extended-public-key-bitcoin'),\n                keyPath, expectedWalletId,\n            ));\n        },\n\n        /**\n         * Sign a transaction. See type declaration of TransactionInfoBitcoin in request-sign-transaction-bitcoin.ts\n         * for documentation of the transaction format. Optionally expect a specific wallet id. The signed transaction\n         * is returned in hex-encoded serialized form ready to be broadcast to the network.\n         */\n        async signTransaction(transaction: TransactionInfoBitcoin, expectedWalletId?: string): Promise<string> {\n            return LedgerApi._callLedger(await LedgerApi._createRequest<RequestSignTransactionBitcoinConstructor>(\n                import('./requests/bitcoin/request-sign-transaction-bitcoin'),\n                transaction, expectedWalletId,\n            ));\n        },\n    };\n\n    public static get currentState(): State {\n        return LedgerApi._currentState;\n    }\n\n    public static get currentRequest(): Request | null {\n        return LedgerApi._currentRequest;\n    }\n\n    public static get isBusy(): boolean {\n        return !!LedgerApi._currentRequest;\n    }\n\n    public static get transportType(): TransportType | null {\n        return LedgerApi._transportType;\n    }\n\n    /**\n     * Check for general support or support of a specific transport type. Note that isSupported is additionally exported\n     * as separate export that doesn't require bundling the whole api.\n     * @param [transportType] - Transport type for which to test for support. If omitted test for support of any type.\n     */\n    public static isSupported(transportType?: TransportType): boolean {\n        return isSupported(transportType);\n    }\n\n    /**\n     * Set a specific transport type. Note that an already connected ongoing request will still use the previous\n     * transport type.\n     * @param transportType - Transport type to use for connections to Ledger devices.\n     */\n    public static setTransportType(transportType: TransportType) {\n        if (!isSupported(transportType)) throw new Error('Unsupported transport type.');\n        if (transportType === LedgerApi._transportType) return;\n        LedgerApi._transportType = transportType;\n        // Close api for current transport to create a new one for specified transport type on next request.\n        LedgerApi.disconnect(/* cancelRequest */ false);\n    }\n\n    public static resetTransportType() {\n        const transportType = autoDetectTransportTypeToUse();\n        if (!transportType) return;\n        LedgerApi.setTransportType(transportType);\n    }\n\n    /**\n     * Manually connect to a Ledger. Typically, this is not required as all requests establish a connection themselves.\n     * However, if that connection fails due to a required user interaction / user gesture, you can manually connect in\n     * the context of a user interaction, for example a click.\n     * @param coin - Which Ledger coin app to connect to.\n     * @param [network] - Only for Bitcoin: whether to connect to the mainnet or testnet app. Mainnet by default.\n     * @returns Whether connecting to the Ledger succeeded.\n     */\n    public static async connect(coin: Coin): Promise<boolean>;\n    public static async connect(coin: Coin.BITCOIN, network: Network): Promise<boolean>;\n    public static async connect(coin: Coin, network: Network = Network.MAINNET): Promise<boolean> {\n        LedgerApi._connectionAborted = false; // reset aborted flag on manual connection\n        try {\n            const { currentRequest, _currentConnection: currentConnection } = LedgerApi;\n            const expectedApp = coin === Coin.NIMIQ ? 'Nimiq' : `Bitcoin${network === Network.TESTNET ? ' Test' : ''}`;\n            if (currentConnection && currentConnection.coin === coin && currentConnection.app === expectedApp) {\n                // Already connected.\n                return true;\n            }\n            if (currentRequest && currentRequest.coin === coin\n                && (!('network' in currentRequest) || currentRequest.network === network)) {\n                // Wait for the ongoing request for coin to connect.\n                // Initialize the transport again if it failed previously, for example due to missing user interaction.\n                await LedgerApi._getTransport(currentRequest);\n                await new Promise<void>((resolve, reject) => {\n                    const onConnect = () => {\n                        LedgerApi.off(EventType.CONNECTED, onConnect);\n                        LedgerApi.off(EventType.REQUEST_CANCELLED, onCancel);\n                        resolve();\n                    };\n                    const onCancel = () => {\n                        LedgerApi.off(EventType.CONNECTED, onConnect);\n                        LedgerApi.off(EventType.REQUEST_CANCELLED, onCancel);\n                        reject(new Error('Request cancelled')); // request cancelled via api before ledger connected\n                    };\n                    LedgerApi.on(EventType.CONNECTED, onConnect);\n                    LedgerApi.on(EventType.REQUEST_CANCELLED, onCancel);\n                });\n                return true;\n            }\n            // Send a request to establish a connection and detect when the ledger is connected.\n            // Note that if the api is already busy with a request for another coin false will be returned.\n            switch (coin) {\n                case Coin.NIMIQ:\n                    await LedgerApi.Nimiq.getWalletId();\n                    return true;\n                case Coin.BITCOIN:\n                    await LedgerApi.Bitcoin.getWalletId(network);\n                    return true;\n                default:\n                    throw new Error(`Unsupported coin: ${coin}`);\n            }\n        } catch (e) {\n            if (e instanceof ErrorState) {\n                LedgerApi._setState(e);\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Disconnect the api and clean up.\n     * @param cancelRequest - Whether to cancel an ongoing request.\n     * @param requestTypesToDisconnect - If specified, only disconnect if no request is going on or if the ongoing\n     *  request is of the specified type.\n     */\n    public static async disconnect(cancelRequest = true, requestTypesToDisconnect?: RequestType | RequestType[]) {\n        const { currentRequest } = LedgerApi;\n        if (currentRequest) {\n            if (requestTypesToDisconnect !== undefined) {\n                requestTypesToDisconnect = Array.isArray(requestTypesToDisconnect)\n                    ? requestTypesToDisconnect\n                    : [requestTypesToDisconnect];\n                if (!requestTypesToDisconnect.includes(currentRequest.type)) return;\n            }\n            if (cancelRequest) {\n                currentRequest.cancel();\n            }\n        }\n\n        const transportPromise = LedgerApi._transportPromise;\n        LedgerApi._transportPromise = null;\n        LedgerApi._currentConnection = null;\n\n        if (!transportPromise) return;\n        try {\n            const api = await transportPromise;\n            await api.close();\n        } catch (e) {\n            // Ignore.\n        }\n    }\n\n    public static on(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.on(eventType, listener);\n    }\n\n    public static off(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.off(eventType, listener);\n    }\n\n    public static once(eventType: EventType, listener: EventListener): void {\n        LedgerApi._observable.once(eventType, listener);\n    }\n\n    // private fields and methods\n    private static _transportType: TransportType | null = autoDetectTransportTypeToUse();\n    private static _transportPromise: Promise<Transport> | null = null;\n    private static _currentState: State = { type: StateType.IDLE };\n    private static _currentRequest: Request | null = null;\n    private static _currentConnection: CoinAppConnection | null = null;\n    private static _connectionAborted: boolean = false;\n    private static readonly _observable = new Observable();\n\n    private static async _createRequest<RC extends RequestConstructor>(\n        requestConstructor: (new (...params: ConstructorParameters<RC>) => InstanceType<RC>)\n        | Promise<{ default: new (...params: ConstructorParameters<RC>) => InstanceType<RC> }>,\n        ...params: ConstructorParameters<RC>\n    ): Promise<InstanceType<RC>> {\n        if (LedgerApi.transportType) {\n            // Prepare transport dependency in parallel. Ignore errors as it's just a preparation.\n            loadTransportLibrary(LedgerApi.transportType).catch(() => {});\n        }\n\n        if (requestConstructor instanceof Promise) {\n            try {\n                requestConstructor = (await requestConstructor).default;\n            } catch (e) {\n                const error = new ErrorState(\n                    ErrorType.LOADING_DEPENDENCIES_FAILED,\n                    `Failed loading dependencies: ${e.message || e}`,\n                    undefined,\n                );\n                LedgerApi._setState(error);\n                throw error;\n            }\n        }\n\n        try {\n            // Note that the requestConstructor is typed as is instead of just RC | Promise<{ default: RC }> such that\n            // typescript can determine which exact request is being created and returned.\n            return new requestConstructor(...params); // eslint-disable-line new-cap\n        } catch (e) {\n            if (e instanceof ErrorState) {\n                LedgerApi._setState(e);\n            }\n            throw e;\n        }\n    }\n\n    private static async _callLedger<R extends Request>(request: R): Promise<ReturnType<R['call']>> {\n        if (LedgerApi.isBusy) {\n            const error = new ErrorState(ErrorType.LEDGER_BUSY, 'Only one call to Ledger at a time allowed', request);\n            LedgerApi._setState(error);\n            throw error;\n        }\n        LedgerApi._connectionAborted = false; // user is initiating a new request\n        try {\n            LedgerApi._currentRequest = request;\n            /* eslint-disable no-await-in-loop, no-async-promise-executor */\n            return await new Promise<ReturnType<R['call']>>(async (resolve, reject) => {\n                let lastRequestCallTime = -1;\n                let canCancelDirectly = true;\n                let cancelFired = false;\n                request.on(REQUEST_EVENT_CANCEL, () => {\n                    // If we can, reject the call right away. Otherwise just notify that the request was requested to be\n                    // cancelled such that the user can cancel the call on the ledger.\n                    if (canCancelDirectly) {\n                        // Note that !!_currentConnection is not an indicator that we can cancel directly, as it's just\n                        // an estimate and we might not actually be disconnected or the request might already have been\n                        // sent before disconnecting.\n                        if (!cancelFired) {\n                            LedgerApi._fire(EventType.REQUEST_CANCELLED, request);\n                            cancelFired = true;\n                        }\n                        reject(new Error('Request cancelled'));\n                    } else {\n                        LedgerApi._setState(StateType.REQUEST_CANCELLING);\n                    }\n                });\n                while (!request.cancelled) {\n                    try {\n                        const transport = await LedgerApi._getTransport(request);\n                        if (request.cancelled) break;\n                        await LedgerApi._connect(transport, request);\n                        if (request.cancelled) break;\n                        LedgerApi._setState(StateType.REQUEST_PROCESSING);\n                        lastRequestCallTime = Date.now();\n                        canCancelDirectly = false; // sending request which has to be resolved / cancelled by the Ledger\n                        const result = await request.call(transport);\n                        if (request.cancelled) break;\n                        LedgerApi._fire(EventType.REQUEST_SUCCESSFUL, request, result);\n                        resolve(result as any);\n                        return;\n                    } catch (e) {\n                        console.debug(e);\n                        if (e instanceof ErrorState) {\n                            LedgerApi._setState(e);\n                        }\n\n                        const message = (e.message || e || '').toLowerCase();\n                        // \"timeout\" used to happen for u2f, it's \"device_ineligible\" or \"other_error\" now (see\n                        // transport-comparison.md). \"timed out\" is for Chrome WebAuthn timeout; \"denied permission\" for\n                        // Firefox WebAuthn timeout.\n                        const isTimeout = /timeout|timed out|denied permission|u2f device_ineligible|u2f other_error/i\n                            .test(message);\n                        const isLocked = /locked|0x6804/i.test(message);\n                        const isConnectedToDashboard = /incorrect length/i.test(message);\n                        canCancelDirectly = canCancelDirectly || isTimeout || isConnectedToDashboard;\n                        if (LedgerApi._transportType === TransportType.U2F\n                            || LedgerApi._transportType === TransportType.WEB_AUTHN\n                            || isLocked) {\n                            // For u2f / webauthn we don't get notified about disconnects therefore clear connection on\n                            // every exception. When locked clear connection for all transport types as user might\n                            // unlock with a different PIN for another wallet.\n                            LedgerApi._currentConnection = null;\n                        }\n                        // Test whether user cancelled call on ledger device or in WebAuthn / U2F browser popup\n                        if (message.indexOf('denied by the user') !== -1 // user rejected confirmAddress on device\n                            || message.indexOf('request was rejected') !== -1 // user rejected signTransaction on device\n                            || (LedgerApi._isWebAuthnOrU2fCancellation(message, lastRequestCallTime)\n                                && !LedgerApi._connectionAborted)\n                        ) {\n                            // Note that on _isWebAuthnOrU2fCancellation we can cancel directly and don't need the user\n                            // to cancel the request on the device as Ledger Nano S is now able to clean up old WebAuthn\n                            // and U2F requests and the the Nano X lets the Nimiq App crash anyways after the WebAuthn /\n                            // U2F host was lost. If the web authn / u2f cancellation was during connect and caused\n                            // _connectionAborted, don't cancel the request.\n                            canCancelDirectly = true;\n                            request.cancel(); // in case the request was not marked as cancelled before\n                            break; // continue after loop where the actual cancellation happens\n                        }\n                        // Errors that should end the request\n                        if ((LedgerApi.currentState instanceof ErrorState\n                            && LedgerApi.currentState.errorType === ErrorType.REQUEST_ASSERTION_FAILED)\n                            || message.indexOf('not supported') !== -1) { // no browser support\n                            reject(e);\n                            return;\n                        }\n                        // On other errors try again\n                        if (!/busy|outdated|connection aborted|user gesture|dependencies|wrong app|wrong wallet/i\n                            .test(message)\n                            && !isTimeout && !isLocked && !isConnectedToDashboard) {\n                            console.warn('Unknown Ledger Error', e);\n                        }\n                        // Wait a little when replacing a previous U2F request (see transport-comparison.md).\n                        const waitTime = isTimeout ? LedgerApi.WAIT_TIME_AFTER_TIMEOUT\n                            // If the API tells us that the ledger is busy (see transport-comparison.md) use a longer\n                            // wait time to reduce the chance that we hit unfortunate 1.5s window after timeout of\n                            // cancelled call\n                            : message.indexOf('busy') !== -1 ? 4 * LedgerApi.WAIT_TIME_AFTER_TIMEOUT\n                                // For other exceptions wait a little to avoid busy endless loop for some exceptions.\n                                : LedgerApi.WAIT_TIME_AFTER_ERROR;\n                        await new Promise((resolve2) => setTimeout(resolve2, waitTime));\n                    }\n                }\n                if (!cancelFired) {\n                    LedgerApi._fire(EventType.REQUEST_CANCELLED, request);\n                    cancelFired = true;\n                }\n                reject(new Error('Request cancelled'));\n            });\n            /* eslint-enable no-await-in-loop, no-async-promise-executor */\n        } finally {\n            LedgerApi._currentRequest = null;\n            if (LedgerApi._transportType === TransportType.U2F\n                || LedgerApi._transportType === TransportType.WEB_AUTHN) {\n                LedgerApi._currentConnection = null; // reset as we don't note when Ledger gets disconnected\n            }\n            const errorType = LedgerApi._currentState instanceof ErrorState\n                ? LedgerApi._currentState.errorType\n                : null;\n            if (errorType !== ErrorType.BROWSER_UNSUPPORTED\n                && errorType !== ErrorType.REQUEST_ASSERTION_FAILED) {\n                LedgerApi._setState(StateType.IDLE);\n            }\n        }\n    }\n\n    private static async _connect(transport: Transport, request: Request): Promise<Transport> {\n        // Resolves when connected to unlocked ledger with open coin app otherwise throws an exception after timeout,\n        // in contrast to the public connect method which just listens for a connection or uses getWalletId to try to\n        // connect repeatedly until success via _callLedger which uses the private _connect under the hood. Also this\n        // method is not publicly exposed to avoid that it could be invoked multiple times in parallel which the ledger\n        // requests called here do not allow.\n\n        // Establish / verify the connection.\n        // This takes <300ms for a pre-authorized device via WebUSB, WebHID or WebBLE and <1s for WebAuthn or U2F.\n        if (!LedgerApi._currentConnection || !request.canReuseCoinAppConnection(LedgerApi._currentConnection)) {\n            const connectStart = Date.now();\n            LedgerApi._setState(StateType.CONNECTING);\n            LedgerApi._currentConnection = null;\n\n            try {\n                LedgerApi._currentConnection = await request.checkCoinAppConnection(transport);\n            } catch (e) {\n                const message = (e.message || e || '').toLowerCase();\n                if (message.indexOf('busy') !== -1) {\n                    throw new ErrorState(\n                        ErrorType.LEDGER_BUSY,\n                        // important to rethrow original message for handling of the 'busy' keyword in _callLedger\n                        `Only one call to Ledger at a time allowed: ${e}`,\n                        request,\n                    );\n                } else if (LedgerApi._isWebAuthnOrU2fCancellation(message, connectStart)) {\n                    LedgerApi._connectionAborted = true;\n                    throw new ErrorState(\n                        ErrorType.CONNECTION_ABORTED,\n                        `Connection aborted: ${message}`,\n                        request,\n                    );\n                }\n\n                // Rethrow other errors that just keep the API retrying (like timeout, dongle locked) or error states.\n                throw e;\n            }\n        }\n\n        LedgerApi._fire(EventType.CONNECTED, LedgerApi._currentConnection);\n        return transport;\n    }\n\n    private static async _getTransport(request: Request): Promise<Transport> {\n        if (LedgerApi._connectionAborted) {\n            // When the connection was aborted, don't retry creating a transport until a manual connection is requested.\n            // Throw as normal error and not as error state as error state had already been reported.\n            throw new Error('Connection aborted');\n        }\n\n        // Create transport. Note that creating the transport has to happen in the context of a user interaction if\n        // opening a device selector is required.\n        const transportType = LedgerApi._transportType;\n        LedgerApi._transportPromise = LedgerApi._transportPromise || (async () => {\n            // Check browser support for current transport. Note that when transport changes during connect, we recurse.\n            if (!transportType || !isSupported(transportType)) {\n                throw new ErrorState(\n                    ErrorType.BROWSER_UNSUPPORTED,\n                    'Ledger not supported by browser.',\n                    request,\n                );\n            }\n\n            // Load transport lib.\n            let TransportLib: TransportWebUsbConstructor | TransportConstructor;\n            // Only set the loading state if the lib is not already loaded or fails instantly.\n            const delayedLoadingStateTimeout = setTimeout(() => LedgerApi._setState(StateType.LOADING), 50);\n            try {\n                TransportLib = await loadTransportLibrary(transportType!);\n            } catch (e) {\n                if (transportType === LedgerApi._transportType) {\n                    throw new ErrorState(\n                        ErrorType.LOADING_DEPENDENCIES_FAILED,\n                        `Failed loading dependencies: ${e.message || e}`,\n                        request,\n                    );\n                }\n            } finally {\n                clearTimeout(delayedLoadingStateTimeout);\n            }\n            if (transportType !== LedgerApi._transportType) throw new Error('Transport changed'); // caught locally\n\n            let transport: Transport;\n            // Only set the connecting state if it is not instantaneous because a device selector needs to be shown\n            const delayedConnectingStateTimeout = setTimeout(() => LedgerApi._setState(StateType.CONNECTING), 50);\n            try {\n                transport = await TransportLib!.create();\n            } catch (e) {\n                if (transportType === LedgerApi._transportType) {\n                    const message = (e.message || e).toLowerCase();\n                    if (/no device selected|access denied|cancelled the requestdevice/i.test(message)) {\n                        if (LedgerApi._transportType === TransportType.WEB_USB) {\n                            // Use a fallback as the user might not have been able to select his device due to the Nano\n                            // X currently not being discoverable via WebUSB in Windows.\n                            // This fallback also temporarily serves Linux users which have not updated their udev rules\n                            // TODO the fallback is just temporary and to be removed once WebUSB with Nano X works on\n                            //  Windows or WebHID is more broadly available.\n                            const fallback = [TransportType.WEB_AUTHN, TransportType.U2F].find(isSupported);\n                            if (!fallback) {\n                                throw new ErrorState(\n                                    ErrorType.BROWSER_UNSUPPORTED,\n                                    'Ledger not supported by browser.',\n                                    request,\n                                );\n                            }\n                            console.warn(`LedgerApi: switching to ${fallback} as fallback`);\n                            LedgerApi.setTransportType(fallback!);\n                        } else {\n                            LedgerApi._connectionAborted = true;\n                            throw new ErrorState(\n                                ErrorType.CONNECTION_ABORTED,\n                                `Connection aborted: ${message}`,\n                                request,\n                            );\n                        }\n                    } else if (message.indexOf('user gesture') !== -1) {\n                        throw new ErrorState(ErrorType.USER_INTERACTION_REQUIRED, e, request);\n                    } else {\n                        throw e; // rethrow unknown exception\n                    }\n                }\n            } finally {\n                clearTimeout(delayedConnectingStateTimeout);\n            }\n            if (transportType !== LedgerApi._transportType) {\n                transport!.close();\n                throw new Error('Transport changed'); // caught locally\n            }\n\n            const onDisconnect = () => {\n                console.debug('Ledger disconnected');\n                transport.off('disconnect', onDisconnect);\n                if (transportType === LedgerApi._transportType) {\n                    // Disconnected transport cannot be reconnected. Thus also disconnect from our side for cleanup.\n                    // If the transport switched, no additional cleanup is necessary as it already happened on switch.\n                    LedgerApi.disconnect(/* cancelRequest */ false);\n                }\n            };\n            transport!.on('disconnect', onDisconnect);\n\n            return transport!;\n        })();\n\n        try {\n            return await LedgerApi._transportPromise;\n        } catch (e) {\n            LedgerApi._transportPromise = null;\n            if (transportType === LedgerApi._transportType) throw e;\n            // Transport type changed while we were connecting; ignore error and rerun\n            return LedgerApi._getTransport(request);\n        }\n    }\n\n    private static _isWebAuthnOrU2fCancellation(errorMessage: string, requestStart: number) {\n        // Try to detect a WebAuthn or U2F cancellation. In Firefox, we can detect a WebAuthn cancellation for the\n        // Firefox internal popup. However, Firefox U2F cancellations, Firefox WebAuthn cancellations via Window's\n        // native popup and Chrome WebAuthn cancellations are not distinguishable from timeouts, therefore we check\n        // how likely it is a timeout by the passed time since request start.\n        return /operation was aborted/i.test(errorMessage) // WebAuthn cancellation in Firefox internal popup\n            || (/timed out|denied permission|u2f other_error/i.test(errorMessage) && Date.now() - requestStart < 20000);\n    }\n\n    private static _setState(state: State | Exclude<StateType, StateType.ERROR>): void {\n        if (typeof state === 'string') {\n            // it's an entry from LedgerApi.StateType enum\n            state = { type: state } as State;\n        }\n        state.request = !state.request && LedgerApi._currentRequest ? LedgerApi._currentRequest : state.request;\n\n        const currentState = LedgerApi._currentState;\n        const currentErrorType = currentState instanceof ErrorState ? currentState.errorType : null;\n        const errorType = state instanceof ErrorState ? state.errorType : null;\n        if (currentState.type === state.type\n            && currentErrorType === errorType\n            && LedgerApi._currentState.request === state.request) return;\n        LedgerApi._currentState = state;\n        LedgerApi._fire(EventType.STATE_CHANGE, state);\n    }\n\n    private static _fire(eventName: EventType, ...args: any[]): void {\n        LedgerApi._observable.fire(eventName, ...args);\n    }\n}\n"],"names":[],"mappings":"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"}