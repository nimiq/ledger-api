{"version":3,"file":"lazy-chunk-index.es3.js","sources":["source-mapped://source-mapped/node_modules/@ledgerhq/logs/src/index.ts"],"sourcesContent":["export type TraceContext = Record<string, unknown>;\nexport type LogData = any;\nexport type LogType = string;\n\n/**\n * A Log object\n */\nexport interface Log {\n  /**\n   * A namespaced identifier of the log (not a level like \"debug\", \"error\" but more like \"apdu\", \"hw\", etc...)\n   */\n  type: LogType;\n  message?: string;\n  /**\n   * Data associated to the log event\n   */\n  data?: LogData;\n  /**\n   * Context data, coming for example from the caller's parent, to enable a simple tracing system\n   */\n  context?: TraceContext;\n  /**\n   * Unique id among all logs\n   */\n  id: string;\n  /*\n   * Date when the log occurred\n   */\n  date: Date;\n}\n\nexport type Unsubscribe = () => void;\nexport type Subscriber = (arg0: Log) => void;\n\nlet id = 0;\nconst subscribers: Subscriber[] = [];\n\n/**\n * Logs something\n *\n * @param type a namespaced identifier of the log (it is not a level like \"debug\", \"error\" but more like \"apdu-in\", \"apdu-out\", etc...)\n * @param message a clear message of the log associated to the type\n */\nexport const log = (type: LogType, message?: string, data?: LogData) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  dispatch(obj);\n};\n\n/**\n * A simple tracer function, only expanding the existing log function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param context Anything representing the context where the log occurred\n */\nexport const trace = ({\n  type,\n  message,\n  data,\n  context,\n}: {\n  type: LogType;\n  message?: string;\n  data?: LogData;\n  context?: TraceContext;\n}) => {\n  const obj: Log = {\n    type,\n    id: String(++id),\n    date: new Date(),\n  };\n\n  if (message) obj.message = message;\n  if (data) obj.data = data;\n  if (context) obj.context = context;\n\n  dispatch(obj);\n};\n\n/**\n * A simple tracer class, that can be used to avoid repetition when using the `trace` function\n *\n * Its goal is to capture more context than a log function.\n * This is simple for now, but can be improved later.\n *\n * @param type A given type (not level) for the current local tracer (\"hw\", \"withDevice\", etc.)\n * @param context Anything representing the context where the log occurred\n */\nexport class LocalTracer {\n  constructor(\n    private type: LogType,\n    private context?: TraceContext,\n  ) {}\n\n  trace(message: string, data?: TraceContext) {\n    trace({\n      type: this.type,\n      message,\n      data,\n      context: this.context,\n    });\n  }\n\n  getContext(): TraceContext | undefined {\n    return this.context;\n  }\n\n  setContext(context?: TraceContext) {\n    this.context = context;\n  }\n\n  updateContext(contextToAdd: TraceContext) {\n    this.context = { ...this.context, ...contextToAdd };\n  }\n\n  getType(): LogType {\n    return this.type;\n  }\n\n  setType(type: LogType) {\n    this.type = type;\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `type`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withType(type: LogType): LocalTracer {\n    return new LocalTracer(type, this.context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with a new `context`\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   *\n   * @param context A TraceContext, that can undefined to reset the context\n   */\n  withContext(context?: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, context);\n  }\n\n  /**\n   * Create a new instance of the LocalTracer with an updated `context`,\n   * on which an additional context is merged with the existing one.\n   *\n   * It does not mutate the calling instance, but returns a new LocalTracer,\n   * following a simple builder pattern.\n   */\n  withUpdatedContext(contextToAdd: TraceContext): LocalTracer {\n    return new LocalTracer(this.type, { ...this.context, ...contextToAdd });\n  }\n}\n\n/**\n * Adds a subscribers to the emitted logs.\n *\n * @param cb that is called for each future log() with the Log object\n * @return a function that can be called to unsubscribe the listener\n */\nexport const listen = (cb: Subscriber): Unsubscribe => {\n  subscribers.push(cb);\n  return () => {\n    const i = subscribers.indexOf(cb);\n\n    if (i !== -1) {\n      // equivalent of subscribers.splice(i, 1) // https://twitter.com/Rich_Harris/status/1125850391155965952\n      subscribers[i] = subscribers[subscribers.length - 1];\n      subscribers.pop();\n    }\n  };\n};\n\nfunction dispatch(log: Log) {\n  for (let i = 0; i < subscribers.length; i++) {\n    try {\n      subscribers[i](log);\n    } catch (e) {\n      console.error(e);\n    }\n  }\n}\n\n// for debug purpose\n\ndeclare global {\n  interface Window {\n    __ledgerLogsListen: any;\n  }\n}\n\nif (typeof window !== \"undefined\") {\n  window.__ledgerLogsListen = listen;\n}\n"],"names":[],"mappings":"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","x_google_ignoreList":[0]}